<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel>
<role name="remi"
      superuser="true"
      password="md5f2adbd142fc53ec8ec79c633ba5ce629">
</role>

<schema name="public" protected="true" rect-visible="true" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<schema name="topology" rect-visible="true" fill-color="#d66b29">
	<role name="postgres"/>
</schema>

<schema name="demo_zone_test" rect-visible="true" fill-color="#a92ceb">
	<role name="postgres"/>
</schema>

<database name="test_topology" encoding="UTF8" lc-collate="en_US" lc-ctype="en_US">
	<role name="remi"/>
	<tablespace name="pg_default"/>
	<comment><![CDATA[Cette base de donnÃ©e servira de base pour les test sur la topologie et le transformation
RGE ---> 2D]]></comment>
</database>

<function name="geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="boolean"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="geometry_enforce_typmod"/>
</function>

<cast cast-type="implicit">
	<type name="geometry"/>
	<type name="geometry"/>
	<function signature="public.geometry(IN geometry,IN integer,IN boolean)"/>
</cast>

<function name="box2d"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<comment><![CDATA[args: geomA - Returns a BOX2D representing the maximum extents of the geometry.]]></comment>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="box2d"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geometry"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="LWGEOM_to_BOX2D"/>
</function>

<cast cast-type="implicit">
	<type name="geometry"/>
	<type name="box2d"/>
	<function signature="public.box2d(IN geometry)"/>
</cast>

<function name="box3d"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<comment><![CDATA[args: geomA - Returns a BOX3D representing the maximum extents of the geometry.]]></comment>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="box3d"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geometry"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="LWGEOM_to_BOX3D"/>
</function>

<cast cast-type="implicit">
	<type name="geometry"/>
	<type name="box3d"/>
	<function signature="public.box3d(IN geometry)"/>
</cast>

<function name="box"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="box"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geometry"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="LWGEOM_to_BOX"/>
</function>

<cast cast-type="implicit">
	<type name="geometry"/>
	<type name="box"/>
	<function signature="public.box(IN geometry)"/>
</cast>

<function name="box2d"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="box2d"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="box3d"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="BOX3D_to_BOX2D"/>
</function>

<cast cast-type="implicit">
	<type name="box3d"/>
	<type name="box2d"/>
	<function signature="public.box2d(IN box3d)"/>
</cast>

<function name="box3d"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="box3d"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="box2d"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="BOX2D_to_BOX3D"/>
</function>

<cast cast-type="implicit">
	<type name="box2d"/>
	<type name="box3d"/>
	<function signature="public.box3d(IN box2d)"/>
</cast>

<function name="geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="box2d"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="BOX2D_to_LWGEOM"/>
</function>

<cast cast-type="implicit">
	<type name="box2d"/>
	<type name="geometry"/>
	<function signature="public.geometry(IN box2d)"/>
</cast>

<function name="box"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="box"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="box3d"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="BOX3D_to_BOX"/>
</function>

<cast cast-type="implicit">
	<type name="box3d"/>
	<type name="box"/>
	<function signature="public.box(IN box3d)"/>
</cast>

<function name="geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="box3d"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="BOX3D_to_LWGEOM"/>
</function>

<cast cast-type="implicit">
	<type name="box3d"/>
	<type name="geometry"/>
	<function signature="public.geometry(IN box3d)"/>
</cast>

<function name="geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="text"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="parse_WKT_lwgeom"/>
</function>

<cast cast-type="implicit">
	<type name="text"/>
	<type name="geometry"/>
	<function signature="public.geometry(IN text)"/>
</cast>

<function name="text"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geometry"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="LWGEOM_to_text"/>
</function>

<cast cast-type="implicit">
	<type name="geometry"/>
	<type name="text"/>
	<function signature="public.text(IN geometry)"/>
</cast>

<function name="geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bytea"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="LWGEOM_from_bytea"/>
</function>

<cast cast-type="implicit">
	<type name="bytea"/>
	<type name="geometry"/>
	<function signature="public.geometry(IN bytea)"/>
</cast>

<function name="bytea"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="bytea"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geometry"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="LWGEOM_to_bytea"/>
</function>

<cast cast-type="implicit">
	<type name="geometry"/>
	<type name="bytea"/>
	<function signature="public.bytea(IN geometry)"/>
</cast>

<function name="geography"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geography"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geography"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="boolean"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="geography_enforce_typmod"/>
</function>

<cast cast-type="implicit">
	<type name="geography"/>
	<type name="geography"/>
	<function signature="public.geography(IN geography,IN integer,IN boolean)"/>
</cast>

<function name="geography"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geography"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bytea"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="LWGEOM_from_bytea"/>
</function>

<cast cast-type="implicit">
	<type name="bytea"/>
	<type name="geography"/>
	<function signature="public.geography(IN bytea)"/>
</cast>

<function name="bytea"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="bytea"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geography"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="LWGEOM_to_bytea"/>
</function>

<cast cast-type="implicit">
	<type name="geography"/>
	<type name="bytea"/>
	<function signature="public.bytea(IN geography)"/>
</cast>

<function name="geography"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geography"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geometry"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="geography_from_geometry"/>
</function>

<cast cast-type="implicit">
	<type name="geometry"/>
	<type name="geography"/>
	<function signature="public.geography(IN geometry)"/>
</cast>

<function name="geometry"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="geography"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="geometry_from_geography"/>
</function>

<extension name="postgis_topology" cur-version="2.1.0">
	<schema name="topology"/>
	<comment><![CDATA[PostGIS topology spatial types and functions]]></comment>
</extension>

<sequence name="topology_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="topology"/>
	<role name="postgres"/>
</sequence>

<table name="topology">
	<schema name="topology"/>
	<role name="postgres"/>
	<position x="783.333" y="226.667"/>
	<column name="id" not-null="true" default-value="nextval('topology_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="name" not-null="true">
		<type name="character varying"/>
	</column>
	<column name="srid" not-null="true">
		<type name="integer"/>
	</column>
	<column name="precision" not-null="true">
		<type name="double precision"/>
	</column>
	<column name="hasz" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<constraint name="topology_pkey" type="pk-constr" factor="100" table="topology.topology">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="topology_name_key" type="uq-constr" factor="100" table="topology.topology">
		<columns names="name" ref-type="src-columns"/>
	</constraint>
</table>

<function name="layertrigger"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  ok BOOL;
  toponame varchar;
  query TEXT;
BEGIN

  --RAISE NOTICE 'LayerTrigger called % % at % level', TG_WHEN, TG_OP, TG_LEVEL;


  IF TG_OP = 'INSERT' THEN
    RAISE EXCEPTION 'LayerTrigger not meant to be called on INSERT';
  ELSIF TG_OP = 'UPDATE' THEN
    RAISE EXCEPTION 'The topology.layer table cannot be updated';
  END IF;


  -- Check for existance of any feature column referencing
  -- this layer
  FOR rec IN SELECT * FROM pg_namespace n, pg_class c, pg_attribute a
    WHERE text(n.nspname) = OLD.schema_name
    AND c.relnamespace = n.oid
    AND text(c.relname) = OLD.table_name
    AND a.attrelid = c.oid
    AND text(a.attname) = OLD.feature_column
  LOOP
    query = 'SELECT * '
      || ' FROM ' || quote_ident(OLD.schema_name)
      || '.' || quote_ident(OLD.table_name)
      || ' WHERE layer_id('
      || quote_ident(OLD.feature_column)||') '
      || '=' || OLD.layer_id
      || ' LIMIT 1';
    --RAISE NOTICE '%', query;
    FOR rec IN EXECUTE query
    LOOP
      RAISE NOTICE 'A feature referencing layer % of topology % still exists in %.%.%', OLD.layer_id, OLD.topology_id, OLD.schema_name, OLD.table_name, OLD.feature_column;
      RETURN NULL;
    END LOOP;
  END LOOP;


  -- Get topology name
  SELECT name FROM topology.topology INTO toponame
    WHERE id = OLD.topology_id;

  IF toponame IS NULL THEN
    RAISE NOTICE 'Could not find name of topology with id %',
      OLD.layer_id;
  END IF;

  -- Check if any record in the relation table references this layer
  FOR rec IN SELECT * FROM pg_namespace
    WHERE text(nspname) = toponame
  LOOP
    query = 'SELECT * '
      || ' FROM ' || quote_ident(toponame)
      || '.relation '
      || ' WHERE layer_id = '|| OLD.layer_id
      || ' LIMIT 1';
    --RAISE NOTICE '%', query;
    FOR rec IN EXECUTE query
    LOOP
      RAISE NOTICE 'A record in %.relation still references layer %', toponame, OLD.layer_id;
      RETURN NULL;
    END LOOP;
  END LOOP;

  RETURN OLD;
END;
]]></definition>
</function>

<table name="layer">
	<schema name="topology"/>
	<role name="postgres"/>
	<position x="1095.33" y="226.667"/>
	<column name="topology_id" not-null="true">
		<type name="integer"/>
	</column>
	<column name="layer_id" not-null="true">
		<type name="integer"/>
	</column>
	<column name="schema_name" not-null="true">
		<type name="character varying"/>
	</column>
	<column name="table_name" not-null="true">
		<type name="character varying"/>
	</column>
	<column name="feature_column" not-null="true">
		<type name="character varying"/>
	</column>
	<column name="feature_type" not-null="true">
		<type name="integer"/>
	</column>
	<column name="level" not-null="true" default-value="0">
		<type name="integer"/>
	</column>
	<column name="child_id">
		<type name="integer"/>
	</column>
	<constraint name="layer_pkey" type="pk-constr" factor="100" table="topology.layer">
		<columns names="topology_id,layer_id" ref-type="src-columns"/>
	</constraint>
	<constraint name="layer_schema_name_table_name_feature_column_key" type="uq-constr" factor="100" table="topology.layer">
		<columns names="schema_name,table_name,feature_column" ref-type="src-columns"/>
	</constraint>
	<trigger name="layer_integrity_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="false" del-event="true" upd-event="true" trunc-event="false"
	 table="topology.layer">
		<function signature="topology.layertrigger()"/>
	</trigger>
</table>

<usertype name="validatetopology_returntype" configuration="composite">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[postgis type: A composite type that consists of an error message and id1 and id2 to denote location of error. This is the return type for ValidateTopology]]></comment>
	<typeattrib name="error">
		<type name="character varying"/>
	</typeattrib>
	<typeattrib name="id1">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="id2">
		<type name="integer"/>
	</typeattrib>
</usertype>

<usertype name="topogeometry" configuration="composite">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[postgis type: A composite type representing a topologically defined geometry]]></comment>
	<typeattrib name="topology_id">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="layer_id">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="type">
		<type name="integer"/>
	</typeattrib>
</usertype>

<domain name="topoelement" constraint="type_range" not-null="false">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[postgis domain: An array of 2 integers generally used to identify a TopoGeometry component.]]></comment>
		<type name="integer" dimension="1"/>
	<expression><![CDATA[((VALUE)[2] > 0)]]></expression>
</domain>

<domain name="topoelementarray" constraint="dimensions" not-null="false">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[postgis domain: An array of TopoElement objects]]></comment>
		<type name="integer" dimension="1"/>
	<expression><![CDATA[(((array_upper(VALUE, 2) IS NOT NULL) AND (array_upper(VALUE, 2) = 2)) AND (array_upper(VALUE, 3) IS NULL))]]></expression>
</domain>

<function name="relationtrigger"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
  toponame varchar;
  topoid integer;
  plyr RECORD; -- parent layer
  rec RECORD;
  ok BOOL;

BEGIN
  IF TG_NARGS != 2 THEN
    RAISE EXCEPTION 'RelationTrigger called with wrong number of arguments';
  END IF;

  topoid = TG_ARGV[0];
  toponame = TG_ARGV[1];

  --RAISE NOTICE 'RelationTrigger called % % on %.relation for a %', TG_WHEN, TG_OP, toponame, TG_LEVEL;


  IF TG_OP = 'DELETE' THEN
    RAISE EXCEPTION 'RelationTrigger not meant to be called on DELETE';
  END IF;

  -- Get layer info (and verify it exists)
  ok = false;
  FOR plyr IN EXECUTE 'SELECT * FROM topology.layer '
    || 'WHERE '
    || ' topology_id = ' || topoid
    || ' AND'
    || ' layer_id = ' || NEW.layer_id
  LOOP
    ok = true;
    EXIT;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION 'Layer % does not exist in topology %',
      NEW.layer_id, topoid;
    RETURN NULL;
  END IF;

  IF plyr.level > 0 THEN -- this is hierarchical layer

    -- ElementType must be the layer child id
    IF NEW.element_type != plyr.child_id THEN
      RAISE EXCEPTION 'Type of elements in layer % must be set to its child layer id %', plyr.layer_id, plyr.child_id;
      RETURN NULL;
    END IF;

    -- ElementId must be an existent TopoGeometry in child layer
    ok = false;
    FOR rec IN EXECUTE 'SELECT topogeo_id FROM '
      || quote_ident(toponame) || '.relation '
      || ' WHERE layer_id = ' || plyr.child_id 
      || ' AND topogeo_id = ' || NEW.element_id
    LOOP
      ok = true;
      EXIT;
    END LOOP;
    IF NOT ok THEN
      RAISE EXCEPTION 'TopoGeometry % does not exist in the child layer %', NEW.element_id, plyr.child_id;
      RETURN NULL;
    END IF;

  ELSE -- this is a basic layer

    -- ElementType must be compatible with layer type
    IF plyr.feature_type != 4
      AND plyr.feature_type != NEW.element_type
    THEN
      RAISE EXCEPTION 'Element of type % is not compatible with layer of type %', NEW.element_type, plyr.feature_type;
      RETURN NULL;
    END IF;

    --
    -- Now lets see if the element is consistent, which
    -- is it exists in the topology tables.
    --

    --
    -- Element is a Node
    --
    IF NEW.element_type = 1 
    THEN
      ok = false;
      FOR rec IN EXECUTE 'SELECT node_id FROM '
        || quote_ident(toponame) || '.node '
        || ' WHERE node_id = ' || NEW.element_id
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Node % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;

    --
    -- Element is an Edge
    --
    ELSIF NEW.element_type = 2 
    THEN
      ok = false;
      FOR rec IN EXECUTE 'SELECT edge_id FROM '
        || quote_ident(toponame) || '.edge_data '
        || ' WHERE edge_id = ' || abs(NEW.element_id)
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Edge % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;

    --
    -- Element is a Face
    --
    ELSIF NEW.element_type = 3 
    THEN
      IF NEW.element_id = 0 THEN
        RAISE EXCEPTION 'Face % cannot be associated with any feature', NEW.element_id;
        RETURN NULL;
      END IF;
      ok = false;
      FOR rec IN EXECUTE 'SELECT face_id FROM '
        || quote_ident(toponame) || '.face '
        || ' WHERE face_id = ' || NEW.element_id
      LOOP
        ok = true;
        EXIT;
      END LOOP;
      IF NOT ok THEN
        RAISE EXCEPTION 'Face % does not exist in topology %', NEW.element_id, toponame;
        RETURN NULL;
      END IF;
    END IF;

  END IF;
  
  RETURN NEW;
END;
]]></definition>
</function>

<function name="addtopogeometrycolumn"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_name, schema_name, table_name, column_name, feature_type, child_layer - Adds a topogeometry column to an existing table, registers this new column as a layer in topology.layer and returns the new layer_id.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="schema" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="tbl" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="col" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="ltype" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="child" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  intltype integer;
  newlevel integer;
  topoid integer;
  rec RECORD;
  newlayer_id integer;
  query text;
BEGIN

        -- Get topology id
        SELECT id FROM topology.topology into topoid
                WHERE name = toponame;

  IF topoid IS NULL THEN
    RAISE EXCEPTION 'Topology % does not exist', toponame;
  END IF;

  IF ltype ILIKE '%POINT%' OR ltype ILIKE 'PUNTAL' THEN
    intltype = 1;
  ELSIF ltype ILIKE '%LINE%' OR ltype ILIKE 'LINEAL' THEN
    intltype = 2;
  ELSIF ltype ILIKE '%POLYGON%' OR ltype ILIKE 'AREAL' THEN
    intltype = 3;
  ELSIF ltype ILIKE '%COLLECTION%' OR ltype ILIKE 'GEOMETRY' THEN
    intltype = 4;
  ELSE
    RAISE EXCEPTION 'Layer type must be one of POINT,LINE,POLYGON,COLLECTION';
  END IF;

  --
  -- Add new TopoGeometry column in schema.table
  --
  EXECUTE 'ALTER TABLE ' || quote_ident(schema)
    || '.' || quote_ident(tbl) 
    || ' ADD COLUMN ' || quote_ident(col)
    || ' topology.TopoGeometry;';


  --
  -- See if child id exists and extract its level
  --
  IF child IS NOT NULL THEN
    SELECT level + 1 FROM topology.layer
      WHERE layer_id = child
      INTO newlevel;
    IF newlevel IS NULL THEN
      RAISE EXCEPTION 'Child layer % does not exist in topology "%"', child, toponame;
    END IF;
  END IF;

  --
  -- Get new layer id from sequence
  --
  EXECUTE 'SELECT nextval(' ||
    quote_literal(
      quote_ident(toponame) || '.layer_id_seq'
    ) || ')' INTO STRICT newlayer_id;

  EXECUTE 'INSERT INTO ' 
    || 'topology.layer(topology_id, '
    || 'layer_id, level, child_id, schema_name, '
    || 'table_name, feature_column, feature_type) '
    || 'VALUES ('
    || topoid || ','
    || newlayer_id || ',' || COALESCE(newlevel, 0) || ','
    || COALESCE(child::text, 'NULL') || ','
    || quote_literal(schema) || ','
    || quote_literal(tbl) || ','
    || quote_literal(col) || ','
    || intltype || ');';


  --
  -- Create a sequence for TopoGeometries in this new layer
  --
  EXECUTE 'CREATE SEQUENCE ' || quote_ident(toponame)
    || '.topogeo_s_' || newlayer_id;

  --
  -- Add constraints on TopoGeom column
  --
  EXECUTE 'ALTER TABLE ' || quote_ident(schema)
    || '.' || quote_ident(tbl) 
    || ' ADD CONSTRAINT "check_topogeom_' || col || '" CHECK ('
    || 'topology_id(' || quote_ident(col) || ') = ' || topoid
    || ' AND '
    || 'layer_id(' || quote_ident(col) || ') = ' || newlayer_id
    || ' AND '
    || 'type(' || quote_ident(col) || ') = ' || intltype
    || ');';

  --
  -- Add dependency of the feature column on the topology schema
  --
  query = 'INSERT INTO pg_catalog.pg_depend SELECT '
    || 'fcat.oid, fobj.oid, fsub.attnum, tcat.oid, '
    || 'tobj.oid, 0, ''n'' '
    || 'FROM pg_class fcat, pg_namespace fnsp, '
    || ' pg_class fobj, pg_attribute fsub, '
    || ' pg_class tcat, pg_namespace tobj '
    || ' WHERE fcat.relname = ''pg_class'' '
    || ' AND fnsp.nspname = ' || quote_literal(schema)
    || ' AND fobj.relnamespace = fnsp.oid '
    || ' AND fobj.relname = ' || quote_literal(tbl)
    || ' AND fsub.attrelid = fobj.oid '
    || ' AND fsub.attname = ' || quote_literal(col)
    || ' AND tcat.relname = ''pg_namespace'' '
    || ' AND tobj.nspname = ' || quote_literal(toponame);

--
-- The only reason to add this dependency is to avoid
-- simple drop of a feature column. Still, drop cascade
-- will remove both the feature column and the sequence
-- corrupting the topology anyway ...
--

  RETURN newlayer_id;
END;
]]></definition>
</function>

<function name="addtopogeometrycolumn"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_name, schema_name, table_name, column_name, feature_type - Adds a topogeometry column to an existing table, registers this new column as a layer in topology.layer and returns the new layer_id.]]></comment>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param4" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param5" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
  SELECT topology.AddTopoGeometryColumn($1, $2, $3, $4, $5, NULL);
]]></definition>
</function>

<function name="droptopogeometrycolumn"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: schema_name, table_name, column_name - Drops the topogeometry column from the table named table_name in schema schema_name and unregisters the columns from topology.layer table.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="schema" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="tbl" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="col" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  lyrinfo RECORD;
  ok BOOL;
  result text;
BEGIN

        -- Get layer and topology info
  ok = false;
  FOR rec IN EXECUTE 'SELECT t.name as toponame, l.* FROM '
    || 'topology.topology t, topology.layer l '
    || ' WHERE l.topology_id = t.id'
    || ' AND l.schema_name = ' || quote_literal(schema)
    || ' AND l.table_name = ' || quote_literal(tbl)
    || ' AND l.feature_column = ' || quote_literal(col)
  LOOP
    ok = true;
    lyrinfo = rec;
  END LOOP;

  -- Layer not found
  IF NOT ok THEN
    RAISE EXCEPTION 'No layer registered on %.%.%',
      schema,tbl,col;
  END IF;
    
  -- Clean up the topology schema
  FOR rec IN SELECT * FROM pg_namespace
    WHERE text(nspname) = lyrinfo.toponame
  LOOP
    -- Cleanup the relation table
    EXECUTE 'DELETE FROM ' || quote_ident(lyrinfo.toponame)
      || '.relation '
      || ' WHERE '
      || 'layer_id = ' || lyrinfo.layer_id;

    -- Drop the sequence for topogeoms in this layer
    EXECUTE 'DROP SEQUENCE ' || quote_ident(lyrinfo.toponame)
      || '.topogeo_s_' || lyrinfo.layer_id;

  END LOOP;

  ok = false;
  FOR rec IN SELECT * FROM pg_namespace n, pg_class c, pg_attribute a
    WHERE text(n.nspname) = schema
    AND c.relnamespace = n.oid
    AND text(c.relname) = tbl
    AND a.attrelid = c.oid
    AND text(a.attname) = col
  LOOP
    ok = true;
    EXIT;
  END LOOP;


  IF ok THEN
    -- Set feature column to NULL to bypass referential integrity
    -- checks
    EXECUTE 'UPDATE ' || quote_ident(schema) || '.'
      || quote_ident(tbl)
      || ' SET ' || quote_ident(col)
      || ' = NULL';
  END IF;

  -- Delete the layer record
  EXECUTE 'DELETE FROM topology.layer '
    || ' WHERE topology_id = ' || lyrinfo.topology_id
    || ' AND layer_id = ' || lyrinfo.layer_id;

  IF ok THEN
    -- Drop the layer column
    EXECUTE 'ALTER TABLE ' || quote_ident(schema) || '.'
      || quote_ident(tbl)
      || ' DROP ' || quote_ident(col)
      || ' cascade';
  END IF;

  result = 'Layer ' || lyrinfo.layer_id || ' ('
    || schema || '.' || tbl || '.' || col
    || ') dropped';

  RETURN result;
END;
]]></definition>
</function>

<function name="gettopologyname"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_id - Returns the name of a topology (schema) given the id of the topology.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="topoid" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  ret varchar;
BEGIN
        SELECT name FROM topology.topology into ret
                WHERE id = topoid;
  RETURN ret;
END
]]></definition>
</function>

<function name="gettopologyid"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: toponame - Returns the SRID of a topology in the topology.topology table given the name of the topology.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  ret integer;
BEGIN
        SELECT id FROM topology.topology into ret
                WHERE name = toponame;
  RETURN ret;
END
]]></definition>
</function>

<function name="gettopologysrid"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
  SELECT SRID FROM topology.topology WHERE name = $1;
]]></definition>
</function>

<function name="createtopology"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_schema_name, srid, tolerance, hasz - Creates a new topology schema and registers this new schema in the topology.topology table.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="srid" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="prec" in="true">
		<type name="double precision"/>
	</parameter>
	<parameter name="hasz" in="true">
		<type name="boolean"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  topology_id integer;
  ndims integer;
BEGIN

--  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
--  LOOP
--    RAISE EXCEPTION 'SQL/MM Spatial exception - schema already exists';
--  END LOOP;

  ndims = 2;
  IF hasZ THEN ndims = 3; END IF;

  ------ Fetch next id for the new topology
  FOR rec IN SELECT nextval('topology.topology_id_seq')
  LOOP
    topology_id = rec.nextval;
  END LOOP;


  EXECUTE 'CREATE SCHEMA ' || quote_ident(atopology);

  -------------{ face CREATION
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.face ('
  || 'face_id SERIAL,'
  || ' CONSTRAINT face_primary_key PRIMARY KEY(face_id)'
  || ');';

  -- Add mbr column to the face table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''face'',''mbr'','||quote_literal(srid)
  ||',''POLYGON'',2)'; -- 2d only mbr is good enough

  -------------} END OF face CREATION


  --------------{ node CREATION

  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.node ('
  || 'node_id SERIAL,'
  --|| 'geom GEOMETRY,'
  || 'containing_face INTEGER,'

  || 'CONSTRAINT node_primary_key PRIMARY KEY(node_id),'

  --|| 'CONSTRAINT node_geometry_type CHECK '
  --|| '( GeometryType(geom) = ''POINT'' ),'

  || 'CONSTRAINT face_exists FOREIGN KEY(containing_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id)'

  || ');';

  -- Add geometry column to the node table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''node'',''geom'','||quote_literal(srid)
  ||',''POINT'',' || ndims || ')';

  --------------} END OF node CREATION

  --------------{ edge CREATION

  -- edge_data table
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.edge_data ('
  || 'edge_id SERIAL NOT NULL PRIMARY KEY,'
  || 'start_node INTEGER NOT NULL,'
  || 'end_node INTEGER NOT NULL,'
  || 'next_left_edge INTEGER NOT NULL,'
  || 'abs_next_left_edge INTEGER NOT NULL,'
  || 'next_right_edge INTEGER NOT NULL,'
  || 'abs_next_right_edge INTEGER NOT NULL,'
  || 'left_face INTEGER NOT NULL,'
  || 'right_face INTEGER NOT NULL,'
  --|| 'geom GEOMETRY NOT NULL,'

  --|| 'CONSTRAINT edge_geometry_type CHECK '
  --|| '( GeometryType(geom) = ''LINESTRING'' ),'

  || 'CONSTRAINT start_node_exists FOREIGN KEY(start_node)'
  || ' REFERENCES ' || quote_ident(atopology) || '.node(node_id),'

  || 'CONSTRAINT end_node_exists FOREIGN KEY(end_node) '
  || ' REFERENCES ' || quote_ident(atopology) || '.node(node_id),'

  || 'CONSTRAINT left_face_exists FOREIGN KEY(left_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id),'

  || 'CONSTRAINT right_face_exists FOREIGN KEY(right_face) '
  || 'REFERENCES ' || quote_ident(atopology) || '.face(face_id),'

  || 'CONSTRAINT next_left_edge_exists FOREIGN KEY(abs_next_left_edge)'
  || ' REFERENCES ' || quote_ident(atopology)
  || '.edge_data(edge_id)'
  || ' DEFERRABLE INITIALLY DEFERRED,'

  || 'CONSTRAINT next_right_edge_exists '
  || 'FOREIGN KEY(abs_next_right_edge)'
  || ' REFERENCES ' || quote_ident(atopology)
  || '.edge_data(edge_id) '
  || ' DEFERRABLE INITIALLY DEFERRED'
  || ');';

  -- Add geometry column to the edge_data table 
  EXECUTE
  'SELECT AddGeometryColumn('||quote_literal(atopology)
  ||',''edge_data'',''geom'','||quote_literal(srid)
  ||',''LINESTRING'',' || ndims || ')';


  -- edge standard view (select rule)
  EXECUTE 'CREATE VIEW ' || quote_ident(atopology)
    || '.edge AS SELECT '
    || ' edge_id, start_node, end_node, next_left_edge, '
    || ' next_right_edge, '
    || ' left_face, right_face, geom FROM '
    || quote_ident(atopology) || '.edge_data';

  -- edge standard view description
  EXECUTE 'COMMENT ON VIEW ' || quote_ident(atopology)
    || '.edge IS '
    || '''Contains edge topology primitives''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.edge_id IS '
    || '''Unique identifier of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.start_node IS '
    || '''Unique identifier of the node at the start of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.end_node IS '
    || '''Unique identifier of the node at the end of the edge''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.next_left_edge IS '
    || '''Unique identifier of the next edge of the face on the left (when looking in the direction from START_NODE to END_NODE), moving counterclockwise around the face boundary''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.next_right_edge IS '
    || '''Unique identifier of the next edge of the face on the right (when looking in the direction from START_NODE to END_NODE), moving counterclockwise around the face boundary''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.left_face IS '
    || '''Unique identifier of the face on the left side of the edge when looking in the direction from START_NODE to END_NODE''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.right_face IS '
    || '''Unique identifier of the face on the right side of the edge when looking in the direction from START_NODE to END_NODE''';
  EXECUTE 'COMMENT ON COLUMN ' || quote_ident(atopology)
    || '.edge.geom IS '
    || '''The geometry of the edge''';

  -- edge standard view (insert rule)
  EXECUTE 'CREATE RULE edge_insert_rule AS ON INSERT '
          || 'TO ' || quote_ident(atopology)
    || '.edge DO INSTEAD '
                || ' INSERT into ' || quote_ident(atopology)
    || '.edge_data '
                || ' VALUES (NEW.edge_id, NEW.start_node, NEW.end_node, '
    || ' NEW.next_left_edge, abs(NEW.next_left_edge), '
    || ' NEW.next_right_edge, abs(NEW.next_right_edge), '
    || ' NEW.left_face, NEW.right_face, NEW.geom);';

  --------------} END OF edge CREATION

  --------------{ layer sequence 
  EXECUTE 'CREATE SEQUENCE '
    || quote_ident(atopology) || '.layer_id_seq;';
  --------------} layer sequence

  --------------{ relation CREATION
  --
  EXECUTE 
  'CREATE TABLE ' || quote_ident(atopology) || '.relation ('
  || ' topogeo_id integer NOT NULL, '
  || ' layer_id integer NOT NULL, ' 
  || ' element_id integer NOT NULL, '
  || ' element_type integer NOT NULL, '
  || ' UNIQUE(layer_id,topogeo_id,element_id,element_type));';

  EXECUTE 
  'CREATE TRIGGER relation_integrity_checks '
  ||'BEFORE UPDATE OR INSERT ON '
  || quote_ident(atopology) || '.relation FOR EACH ROW '
  || ' EXECUTE PROCEDURE topology.RelationTrigger('
  ||topology_id||','||quote_literal(atopology)||')';
  --------------} END OF relation CREATION

  
  ------- Default (world) face
  EXECUTE 'INSERT INTO ' || quote_ident(atopology) || '.face(face_id) VALUES(0);';

  ------- GiST index on face
  EXECUTE 'CREATE INDEX face_gist ON '
    || quote_ident(atopology)
    || '.face using gist (mbr);';

  ------- GiST index on node
  EXECUTE 'CREATE INDEX node_gist ON '
    || quote_ident(atopology)
    || '.node using gist (geom);';

  ------- GiST index on edge
  EXECUTE 'CREATE INDEX edge_gist ON '
    || quote_ident(atopology)
    || '.edge_data using gist (geom);';

  ------- Indexes on left_face and right_face of edge_data
  ------- NOTE: these indexes speed up GetFaceGeometry (and thus
  -------       TopoGeometry::Geometry) by a factor of 10 !
  -------       See http://trac.osgeo.org/postgis/ticket/806
  EXECUTE 'CREATE INDEX edge_left_face_idx ON '
    || quote_ident(atopology)
    || '.edge_data (left_face);';
  EXECUTE 'CREATE INDEX edge_right_face_idx ON '
    || quote_ident(atopology)
    || '.edge_data (right_face);';

  ------- Indexes on start_node and end_node of edge_data
  ------- NOTE: this indexes speed up node deletion
  -------       by a factor of 1000 !
  -------       See http://trac.osgeo.org/postgis/ticket/2082
  EXECUTE 'CREATE INDEX edge_start_node_idx ON '
    || quote_ident(atopology)
    || '.edge_data (start_node);';
  EXECUTE 'CREATE INDEX edge_end_node_idx ON '
    || quote_ident(atopology)
    || '.edge_data (end_node);';

  -- TODO: consider also adding an index on node.containing_face 

  ------- Add record to the "topology" metadata table
  EXECUTE 'INSERT INTO topology.topology '
    || '(id, name, srid, precision, hasZ) VALUES ('
    || quote_literal(topology_id) || ','
    || quote_literal(atopology) || ','
    || quote_literal(srid) || ',' || quote_literal(prec)
    || ',' || hasZ
    || ')';

  RETURN topology_id;
END
]]></definition>
</function>

<function name="createtopology"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_schema_name, srid, tolerance - Creates a new topology schema and registers this new schema in the topology.topology table.]]></comment>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="srid" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="prec" in="true">
		<type name="double precision"/>
	</parameter>
	<definition><![CDATA[ SELECT topology.CreateTopology($1, $2, $3, false);]]></definition>
</function>

<function name="createtopology"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_schema_name, srid - Creates a new topology schema and registers this new schema in the topology.topology table.]]></comment>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[ SELECT topology.CreateTopology($1, $2, 0); ]]></definition>
</function>

<function name="createtopology"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_schema_name - Creates a new topology schema and registers this new schema in the topology.topology table.]]></comment>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[ SELECT topology.CreateTopology($1, ST_SRID('POINT EMPTY'::geometry), 0); ]]></definition>
</function>

<function name="droptopology"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_schema_name - Use with caution: Drops a topology schema and deletes its reference from topology.topology table and references to tables in that schema from the geometry_columns table.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  topoid integer;
  rec RECORD;
BEGIN

  -- Get topology id
        SELECT id FROM topology.topology into topoid
                WHERE name = atopology;


  IF topoid IS NOT NULL THEN

    RAISE NOTICE 'Dropping all layers from topology % (%)',
      atopology, topoid;

    -- Drop all layers in the topology
    FOR rec IN EXECUTE 'SELECT * FROM topology.layer WHERE '
      || ' topology_id = ' || topoid
    LOOP

      EXECUTE 'SELECT topology.DropTopoGeometryColumn('
        || quote_literal(rec.schema_name)
        || ','
        || quote_literal(rec.table_name)
        || ','
        || quote_literal(rec.feature_column)
        || ')';
    END LOOP;

    -- Delete record from topology.topology
    EXECUTE 'DELETE FROM topology.topology WHERE id = '
      || topoid;

  END IF;


  -- Drop the schema (if it exists)
  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
  LOOP
    EXECUTE 'DROP SCHEMA '||quote_ident(atopology)||' CASCADE';
  END LOOP;

  RETURN 'Topology ' || quote_literal(atopology) || ' dropped';
END
]]></definition>
</function>

<function name="topologysummary"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_schema_name - Takes a topology name and provides summary totals of types of objects in topology]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  rec2 RECORD;
  var_topology_id integer;
  n int4;
  missing int4;
  sql text;
  ret text;
BEGIN

  ret := 'Topology ' || quote_ident(atopology) ;

  BEGIN
    SELECT * FROM topology.topology WHERE name = atopology INTO STRICT rec;
    -- TODO: catch <no_rows> to give a nice error message
    var_topology_id := rec.id;

    ret := ret || ' (' || rec.id || '), ';
    ret := ret || 'SRID ' || rec.srid || ', '
               || 'precision ' || rec.precision;
    IF rec.hasz THEN ret := ret || ', has Z'; END IF;
    ret := ret || E'\n';
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ret := ret || E' (X)\n';
  END;

  BEGIN

  BEGIN
    EXECUTE 'SELECT count(node_id) FROM ' || quote_ident(atopology)
      || '.node ' INTO STRICT n;
    ret = ret || n || ' nodes, ';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'X nodes, ';
  END;

  BEGIN
    EXECUTE 'SELECT count(edge_id) FROM ' || quote_ident(atopology)
      || '.edge_data ' INTO STRICT n;
    ret = ret || n || ' edges, ';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'X edges, ';
  END;

  BEGIN
    EXECUTE 'SELECT count(face_id) FROM ' || quote_ident(atopology)
      || '.face WHERE face_id != 0' INTO STRICT n;
    ret = ret || n || ' faces, ';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'X faces, ';
  END;

  BEGIN

    EXECUTE 'SELECT count(*) FROM (SELECT DISTINCT layer_id,topogeo_id FROM '
      || quote_ident(atopology) || '.relation ) foo ' INTO STRICT n;
    ret = ret || n || ' topogeoms in ';

    EXECUTE 'SELECT count(*) FROM (SELECT DISTINCT layer_id FROM '
      || quote_ident(atopology) || '.relation ) foo ' INTO STRICT n;
    ret = ret || n || ' layers' || E'\n';
  EXCEPTION
    WHEN UNDEFINED_TABLE OR INVALID_SCHEMA_NAME THEN
      ret = ret || 'X topogeoms in X layers' || E'\n';
  END;

  -- print information about registered layers
  FOR rec IN SELECT * FROM topology.layer l
    WHERE l.topology_id = var_topology_id
    ORDER by layer_id
  LOOP -- {
    ret = ret || 'Layer ' || rec.layer_id || ', type ';
    CASE
      WHEN rec.feature_type = 1 THEN
        ret = ret || 'Puntal';
      WHEN rec.feature_type = 2 THEN
        ret = ret || 'Lineal';
      WHEN rec.feature_type = 3 THEN
        ret = ret || 'Polygonal';
      WHEN rec.feature_type = 4 THEN
        ret = ret || 'Mixed';
      ELSE 
        ret = ret || '???';
    END CASE;

    ret = ret || ' (' || rec.feature_type || '), ';

    BEGIN

      EXECUTE 'SELECT count(*) FROM ( SELECT DISTINCT topogeo_id FROM '
        || quote_ident(atopology)
        || '.relation r WHERE r.layer_id = ' || rec.layer_id
        || ' ) foo ' INTO STRICT n;

      ret = ret || n || ' topogeoms' || E'\n';

    EXCEPTION WHEN UNDEFINED_TABLE THEN
      ret = ret || 'X topogeoms' || E'\n';
    END;

      IF rec.level > 0 THEN
        ret = ret || ' Hierarchy level ' || rec.level 
                  || ', child layer ' || rec.child_id || E'\n';
      END IF;

      ret = ret || ' Deploy: ';
      IF rec.feature_column != '' THEN
        ret = ret || quote_ident(rec.schema_name) || '.'
                  || quote_ident(rec.table_name) || '.'
                  || quote_ident(rec.feature_column);

        IF n > 0 THEN
          sql := 'SELECT count(*) FROM ( SELECT topogeo_id FROM '
            || quote_ident(atopology)
            || '.relation r WHERE r.layer_id = ' || rec.layer_id
            || ' EXCEPT SELECT DISTINCT id('
            || quote_ident(rec.feature_column) || ') FROM '
            || quote_ident(rec.schema_name) || '.'
            || quote_ident(rec.table_name) || ') as foo';
          EXECUTE sql INTO STRICT missing;
          IF missing > 0 THEN
            ret = ret || ' (' || missing || ' missing topogeoms)';
          END IF;
        END IF;
        ret = ret || E'\n';

      ELSE
        ret = ret || E'NONE (detached)\n';
      END IF;

  END LOOP; -- }

  -- print information about unregistered layers containing topogeoms
  sql := 'SELECT layer_id FROM '
      || quote_ident(atopology) || '.relation EXCEPT SELECT layer_id'
      || ' FROM topology.layer WHERE topology_id = '
      || var_topology_id || 'ORDER BY layer_id';
  --RAISE DEBUG '%', sql;
  FOR rec IN  EXECUTE sql
  LOOP -- {
    ret = ret || 'Layer ' || rec.layer_id::text || ', UNREGISTERED, ';

    EXECUTE 'SELECT count(*) FROM ( SELECT DISTINCT topogeo_id FROM '
      || quote_ident(atopology)
      || '.relation r WHERE r.layer_id = ' || rec.layer_id
      || ' ) foo ' INTO STRICT n;

    ret = ret || n || ' topogeoms' || E'\n';

  END LOOP; -- }

  EXCEPTION
    WHEN INVALID_SCHEMA_NAME THEN
      ret = ret || E'\n- missing schema - ';
    WHEN OTHERS THEN
      RAISE EXCEPTION 'Got % (%)', SQLERRM, SQLSTATE;
  END;


  RETURN ret;
END
]]></definition>
</function>

<function name="copytopology"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: existing_topology_name, new_name - Makes a copy of a topology structure (nodes, edges, faces, layers and TopoGeometries).]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="newtopo" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  rec2 RECORD;
  oldtopo_id integer;
  newtopo_id integer;
  n int4;
  ret text;
BEGIN

  SELECT * FROM topology.topology where name = atopology
  INTO strict rec;
  oldtopo_id = rec.id;
  -- TODO: more gracefully handle unexistent topology

  SELECT topology.CreateTopology(newtopo, rec.SRID, rec.precision, rec.hasZ)
  INTO strict newtopo_id;

  -- Copy faces
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.face SELECT * FROM ' || quote_ident(atopology)
    || '.face WHERE face_id != 0';
  -- Update faces sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.face_face_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.face_face_id_seq))';

  -- Copy nodes
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.node SELECT * FROM ' || quote_ident(atopology)
    || '.node';
  -- Update node sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.node_node_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.node_node_id_seq))';

  -- Copy edges
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.edge_data SELECT * FROM ' || quote_ident(atopology)
    || '.edge_data';
  -- Update edge sequence
  EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.edge_data_edge_id_seq'
    ) || ', (SELECT last_value FROM ' 
    || quote_ident(atopology) || '.edge_data_edge_id_seq))';

  -- Copy layers and their TopoGeometry sequences 
  FOR rec IN SELECT * FROM topology.layer WHERE topology_id = oldtopo_id
  LOOP
    INSERT INTO topology.layer (topology_id, layer_id, feature_type,
      level, child_id, schema_name, table_name, feature_column) 
      VALUES (newtopo_id, rec.layer_id, rec.feature_type,
              rec.level, rec.child_id, newtopo,
              'LAYER' ||  rec.layer_id, '');
    -- Create layer's TopoGeometry sequences
    EXECUTE 'SELECT last_value FROM ' 
      || quote_ident(atopology) || '.topogeo_s_' || rec.layer_id 
      INTO STRICT n;
    EXECUTE 'CREATE SEQUENCE ' || quote_ident(newtopo)
      || '.topogeo_s_' || rec.layer_id;
    EXECUTE 'SELECT setval(' || quote_literal(
      quote_ident(newtopo) || '.topogeo_s_' || rec.layer_id
      ) || ', ' || n || ')';
  END LOOP;

  -- Copy TopoGeometry definitions
  EXECUTE 'INSERT INTO ' || quote_ident(newtopo)
    || '.relation SELECT * FROM ' || quote_ident(atopology)
    || '.relation';

  RETURN newtopo_id;
END
]]></definition>
</function>

<function name="getnodebypoint"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, point, tol - Find the id of a node at a point location]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="tol1" in="true">
		<type name="double precision"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	sql text;
	idnode int;
BEGIN
	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR apoint IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Apoint must be a point
	--
	IF substring(geometrytype(apoint), 1, 5) != 'POINT'
	THEN
		RAISE EXCEPTION 'Node geometry must be a point';
	END IF;

	--
	-- Tolerance must be >= 0
	--
	IF tol1 < 0
	THEN
		RAISE EXCEPTION 'Tolerance must be >=0';
	END IF;


    if tol1 = 0 then
    	sql := 'SELECT a.node_id FROM ' 
        || quote_ident(atopology) 
        || '.node as a WHERE '
        || '(a.geom && ' || quote_literal(apoint::text)||'::geometry) '
        || ' AND (ST_Intersects(a.geom,' || quote_literal(apoint::text)||'::geometry) );';
    else
    	sql := 'SELECT a.node_id FROM ' 
        || quote_ident(atopology) 
        || '.node as a WHERE '
        || '(ST_DWithin(a.geom,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ') );';
    end if;

    BEGIN
    EXECUTE sql INTO STRICT idnode;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            idnode = 0;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'Two or more nodes found';
    END;

	RETURN idnode;
	
END
]]></definition>
</function>

<function name="getedgebypoint"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, apoint, tol - Find the edge-id of an edge that intersects a given point]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="tol1" in="true">
		<type name="double precision"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	sql text;
	idedge int;
BEGIN
	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR apoint IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Apoint must be a point
	--
	IF substring(geometrytype(apoint), 1, 5) != 'POINT'
	THEN
		RAISE EXCEPTION 'Node geometry must be a point';
	END IF;

	--
	-- Tolerance must be >= 0
	--
	IF tol1 < 0
	THEN
		RAISE EXCEPTION 'Tolerance must be >=0';
	END IF;


    if tol1 = 0 then
    	sql := 'SELECT a.edge_id FROM ' 
        || quote_ident(atopology) 
        || '.edge_data as a WHERE '
        || '(a.geom && ' || quote_literal(apoint::text)||'::geometry) '
        || ' AND (ST_Intersects(a.geom,' || quote_literal(apoint::text)||'::geometry) );';
    else
    	sql := 'SELECT a.edge_id FROM ' 
        || quote_ident(atopology) 
        || '.edge_data as a WHERE '
        || '(ST_DWithin(a.geom,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ') );';
    end if;

    BEGIN
    EXECUTE sql INTO STRICT idedge;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            idedge = 0;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'Two or more edges found';
    END;

	RETURN idedge;
	
END
]]></definition>
</function>

<function name="getfacebypoint"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, apoint, tol - Find the face-id of a face that intersects a given point]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="tol1" in="true">
		<type name="double precision"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	sql text;
	idface int;
BEGIN

    idface := -1;

	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR apoint IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Apoint must be a point
	--
	IF substring(geometrytype(apoint), 1, 5) != 'POINT'
	THEN
		RAISE EXCEPTION 'Node geometry must be a point';
	END IF;

	--
	-- Tolerance must be >= 0
	--
	IF tol1 < 0
	THEN
		RAISE EXCEPTION 'Tolerance must be >=0';
	END IF;
    --
    -- first test is to check if there is inside an mbr
    --
    if tol1 = 0 then
    	sql := 'SELECT a.face_id FROM ' 
        || quote_ident(atopology) 
        || '.face as a WHERE '
        || '(a.mbr && ' || quote_literal(apoint::text)||'::geometry) '
        || 'LIMIT 1;';
    else
    	sql := 'SELECT a.face_id FROM ' 
        || quote_ident(atopology) 
        || '.face as a WHERE '
        || '(ST_DWithin(a.mbr,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ') ) '
        || 'LIMIT 1;';
    end if;

    BEGIN
    EXECUTE sql INTO STRICT idface;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            idface = 0;
    END;

    if idface > 0 then
        --
        -- probably there is something so now check the exact test
        --

    	if tol1 = 0 then
        	sql := 'SELECT e.face_id FROM ('
            || 'SELECT d.face_id,ST_BuildArea(ST_Union(geom)) as geom FROM ('
    		|| 'SELECT b.edge_id as edge_id,b.left_face as face_id,b.geom as geom FROM '
        	|| quote_ident(atopology) || '.edge_data as b,'
            || '(SELECT a.face_id FROM '
    		|| quote_ident(atopology) || '.face as a '
        	|| 'WHERE ST_Intersects(a.mbr,' || quote_literal(apoint::text)||'::geometry)=true'
            || ') as c '
    		|| 'WHERE (b.left_face = c.face_id) '
        	|| ' UNION ALL '
            || 'SELECT b.edge_id as edge_id, b.right_face as face_id, b.geom as geom FROM '
    		|| quote_ident(atopology) || '.edge_data as b,'
        	|| '(SELECT a.face_id FROM '
            || quote_ident(atopology) || '.face as a '
    		|| 'WHERE ST_Intersects(a.mbr,' || quote_literal(apoint::text)||'::geometry)=true'
        	|| ') as c '
            || 'WHERE (b.right_face = c.face_id) '
    		|| ') as d '
        	|| 'GROUP BY face_id '
            || ') as e '
    		|| 'WHERE ST_Intersects(e.geom, ' || quote_literal(apoint::text)||'::geometry)=true;';
        else
        	sql := 'SELECT e.face_id FROM ('
            || 'SELECT d.face_id,ST_BuildArea(ST_Union(geom)) as geom FROM ('
    		|| 'SELECT b.edge_id as edge_id,b.left_face as face_id,b.geom as geom FROM '
        	|| quote_ident(atopology) || '.edge_data as b,'
            || '(SELECT a.face_id FROM '
    		|| quote_ident(atopology) || '.face as a '
        	|| 'WHERE ST_DWithin(a.mbr,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ')=true'
            || ') as c '
    		|| 'WHERE (b.left_face = c.face_id) '
        	|| ' UNION ALL '
            || 'SELECT b.edge_id as edge_id, b.right_face as face_id, b.geom as geom FROM '
    		|| quote_ident(atopology) || '.edge_data as b,'
        	|| '(SELECT a.face_id FROM '
            || quote_ident(atopology) || '.face as a '
    		|| 'WHERE ST_DWithin(a.mbr,' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ')=true'
        	|| ') as c '
            || 'WHERE (b.right_face = c.face_id) '
    		|| ') as d '
        	|| 'GROUP BY face_id '
            || ') as e '
    		|| 'WHERE ST_DWithin(e.geom, ' || quote_literal(apoint::text)||'::geometry,' || tol1::text || ')=true;';
        end if;
	
    	RAISE DEBUG ' ==> %',sql;

        BEGIN
            EXECUTE sql INTO STRICT idface;
        	EXCEPTION
        	    WHEN NO_DATA_FOUND THEN
                    idface = 0;
                WHEN TOO_MANY_ROWS THEN
                    RAISE EXCEPTION 'Two or more faces found';
            END;

    end if;
    
    RETURN idface;
	
END
]]></definition>
</function>

<function name="_st_mintolerance"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="ageom" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
    SELECT 3.6 * power(10,  - ( 15 - log(coalesce(
      nullif(
        greatest(abs(ST_xmin($1)), abs(ST_ymin($1)),
                 abs(ST_xmax($1)), abs(ST_ymax($1))),
        0),
      1)) ));
]]></definition>
</function>

<function name="_st_mintolerance"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="ageom" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  ret FLOAT8;
BEGIN
  SELECT COALESCE(
    NULLIF(precision, 0),
    topology._st_mintolerance($2))
  FROM topology.topology
  WHERE name = $1 INTO ret;
  IF NOT FOUND THEN
    RAISE EXCEPTION
      'No topology with name "%" in topology.topology', atopology;
  END IF;
  return ret;
END;
]]></definition>
</function>

<function name="addnode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: toponame, apoint, allowEdgeSplitting=false, computeContainingFace=false - Adds a point node to the node table in the specified topology schema and returns the nodeid of new node. If point already exists as node, the existing nodeid is returned.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true" default-value="false">
		<type name="character varying"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="allowedgesplitting" in="true">
		<type name="boolean"/>
	</parameter>
	<parameter name="setcontainingface" in="true">
		<type name="boolean"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	nodeid int;
	rec RECORD;
  containing_face int;
BEGIN
	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR apoint IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Apoint must be a point
	--
	IF substring(geometrytype(apoint), 1, 5) != 'POINT'
	THEN
		RAISE EXCEPTION 'Node geometry must be a point';
	END IF;

	--
	-- Check if a coincident node already exists
	-- 
	-- We use index AND x/y equality
	--
	FOR rec IN EXECUTE 'SELECT node_id FROM '
		|| quote_ident(atopology) || '.node ' ||
		'WHERE geom && ' || quote_literal(apoint::text) || '::geometry'
		||' AND ST_X(geom) = ST_X('||quote_literal(apoint::text)||'::geometry)'
		||' AND ST_Y(geom) = ST_Y('||quote_literal(apoint::text)||'::geometry)'
	LOOP
		RETURN  rec.node_id;
	END LOOP;

	--
	-- Check if any edge crosses this node
	-- (endpoints are fine)
	--
	FOR rec IN EXECUTE 'SELECT edge_id FROM '
		|| quote_ident(atopology) || '.edge ' 
		|| 'WHERE ST_DWithin('
		|| quote_literal(apoint::text) 
		|| ', geom, 0) AND NOT ST_Equals('
		|| quote_literal(apoint::text)
		|| ', ST_StartPoint(geom)) AND NOT ST_Equals('
		|| quote_literal(apoint::text)
		|| ', ST_EndPoint(geom))'
	LOOP
    IF allowEdgeSplitting THEN
      RETURN ST_ModEdgeSplit(atopology, rec.edge_id, apoint);
    ELSE
		  RAISE EXCEPTION 'An edge crosses the given node.';
    END IF;
	END LOOP;

  IF setContainingFace THEN
    containing_face := topology.GetFaceByPoint(atopology, apoint, 0);
  ELSE
    containing_face := NULL;
  END IF;

	--
	-- Get new node id from sequence
	--
	FOR rec IN EXECUTE 'SELECT nextval(' ||
		quote_literal(
			quote_ident(atopology) || '.node_node_id_seq'
		) || ')'
	LOOP
		nodeid = rec.nextval;
	END LOOP;

	--
	-- Insert the new row
	--
	EXECUTE 'INSERT INTO ' || quote_ident(atopology)
		|| '.node(node_id, containing_face, geom) 
		VALUES(' || nodeid || ',' || coalesce(containing_face::text, 'NULL') || ','
    || quote_literal(apoint::text) || ')';

	RETURN nodeid;
	
END
]]></definition>
</function>

<function name="addnode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
  SELECT topology.AddNode($1, $2, false, false);
]]></definition>
</function>

<function name="addedge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: toponame, aline - Adds a linestring edge to the edge table and associated start and end points to the point nodes table of the specified topology schema using the specified linestring geometry and returns the edgeid of the new (or existing) edge.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="aline" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	edgeid int;
	rec RECORD;
  ix geometry; 
BEGIN
	--
	-- Atopology and apoint are required
	-- 
	IF atopology IS NULL OR aline IS NULL THEN
		RAISE EXCEPTION 'Invalid null argument';
	END IF;

	--
	-- Aline must be a linestring
	--
	IF substring(geometrytype(aline), 1, 4) != 'LINE'
	THEN
		RAISE EXCEPTION 'Edge geometry must be a linestring';
	END IF;

	--
	-- Check there's no face registered in the topology
	--
	FOR rec IN EXECUTE 'SELECT count(face_id) FROM '
		|| quote_ident(atopology) || '.face '
		|| ' WHERE face_id != 0 LIMIT 1'
	LOOP
		IF rec.count > 0 THEN
			RAISE EXCEPTION 'AddEdge can only be used against topologies with no faces defined';
		END IF;
	END LOOP;

	--
	-- Check if the edge crosses an existing node
	--
	FOR rec IN EXECUTE 'SELECT node_id FROM '
		|| quote_ident(atopology) || '.node '
		|| 'WHERE ST_Crosses('
		|| quote_literal(aline::text) || '::geometry, geom'
		|| ')'
	LOOP
		RAISE EXCEPTION 'Edge crosses node %', rec.node_id;
	END LOOP;

	--
	-- Check if the edge intersects an existing edge
	-- on anything but endpoints
	--
	-- Following DE-9 Intersection Matrix represent
	-- the only relation we accept. 
	--
	--    F F 1
	--    F * *
	--    1 * 2
	--
	-- Example1: linestrings touching at one endpoint
	--    FF1 F00 102
	--    FF1 F** 1*2 <-- our match
	--
	-- Example2: linestrings touching at both endpoints
	--    FF1 F0F 1F2
	--    FF1 F** 1*2 <-- our match
	--
	FOR rec IN EXECUTE 'SELECT edge_id, geom, ST_Relate('
		|| quote_literal(aline::text)
		|| '::geometry, geom, 2) as im'
		|| ' FROM '
		|| quote_ident(atopology) || '.edge '
		|| 'WHERE '
		|| quote_literal(aline::text) || '::geometry && geom'

	LOOP

	  IF ST_RelateMatch(rec.im, 'FF1F**1*2') THEN
	    CONTINUE; -- no interior intersection
	  END IF;

	  -- Reuse an EQUAL edge (be it closed or not)
	  IF ST_RelateMatch(rec.im, '1FFF*FFF2') THEN
	      RETURN rec.edge_id;
	  END IF;

	  -- WARNING: the constructive operation might throw an exception
	  BEGIN
	    ix = ST_Intersection(rec.geom, aline);
	  EXCEPTION
	  WHEN OTHERS THEN
	    RAISE NOTICE 'Could not compute intersection between input edge (%) and edge % (%)', aline::text, rec.edge_id, rec.geom::text;
	  END;

	  RAISE EXCEPTION 'Edge intersects (not on endpoints) with existing edge % at or near point %', rec.edge_id, ST_AsText(ST_PointOnSurface(ix));

	END LOOP;

	--
	-- Get new edge id from sequence
	--
	FOR rec IN EXECUTE 'SELECT nextval(' ||
		quote_literal(
			quote_ident(atopology) || '.edge_data_edge_id_seq'
		) || ')'
	LOOP
		edgeid = rec.nextval;
	END LOOP;

	--
	-- Insert the new row
	--
	EXECUTE 'INSERT INTO '
		|| quote_ident(atopology)
		|| '.edge(edge_id, start_node, end_node, '
		|| 'next_left_edge, next_right_edge, '
		|| 'left_face, right_face, '
		|| 'geom) '
		|| ' VALUES('

		-- edge_id
		|| edgeid ||','

		-- start_node
		|| 'topology.addNode('
		|| quote_literal(atopology)
		|| ', ST_StartPoint('
		|| quote_literal(aline::text)
		|| ')) ,'

		-- end_node
		|| 'topology.addNode('
		|| quote_literal(atopology)
		|| ', ST_EndPoint('
		|| quote_literal(aline::text)
		|| ')) ,'

		-- next_left_edge
		|| -edgeid ||','

		-- next_right_edge
		|| edgeid ||','

		-- left_face
		|| '0,'

		-- right_face
		|| '0,'

		-- geom
		||quote_literal(aline::text)
		|| ')';

	RETURN edgeid;
	
END
]]></definition>
</function>

<function name="addface"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: toponame, apolygon, force_new=false - Registers a face primitive to a topology and get its identifier.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true" default-value="false">
		<type name="character varying"/>
	</parameter>
	<parameter name="apoly" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="force_new" in="true">
		<type name="boolean"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  bounds geometry;
  symdif geometry;
  faceid int;
  rec RECORD;
  rrec RECORD;
  relate text;
  right_edges int[];
  left_edges int[];
  all_edges geometry;
  old_faceid int;
  old_edgeid int;
  sql text;
  right_side bool;
  edgeseg geometry;
  p1 geometry;
  p2 geometry;
  p3 geometry;
  loc float8;
  segnum int;
  numsegs int;
BEGIN
  --
  -- Atopology and apoly are required
  -- 
  IF atopology IS NULL OR apoly IS NULL THEN
    RAISE EXCEPTION 'Invalid null argument';
  END IF;

  --
  -- Aline must be a polygon
  --
  IF substring(geometrytype(apoly), 1, 4) != 'POLY'
  THEN
    RAISE EXCEPTION 'Face geometry must be a polygon';
  END IF;

  for rrec IN SELECT (ST_DumpRings(ST_ForceRHR(apoly))).geom
  LOOP -- {
    --
    -- Find all bounds edges, forcing right-hand-rule
    -- to know what's left and what's right...
    --
    bounds = ST_Boundary(rrec.geom);

    sql := 'SELECT e.geom, e.edge_id, '
      || 'e.left_face, e.right_face FROM '
      || quote_ident(atopology) || '.edge e, (SELECT '
      || quote_literal(bounds::text)
      || '::geometry as geom) r WHERE '
      || 'r.geom && e.geom'
    ;
    -- RAISE DEBUG 'SQL: %', sql;
    FOR rec IN EXECUTE sql
    LOOP -- {
      --RAISE DEBUG 'Edge % has bounding box intersection', rec.edge_id;

      -- Find first non-empty segment of the edge
      numsegs = ST_NumPoints(rec.geom);
      segnum = 1;
      WHILE segnum < numsegs LOOP
        p1 = ST_PointN(rec.geom, segnum);
        p2 = ST_PointN(rec.geom, segnum+1);
        IF ST_Distance(p1, p2) > 0 THEN
          EXIT;
        END IF;
        segnum = segnum + 1;
      END LOOP;

      IF segnum = numsegs THEN
        RAISE WARNING 'Edge % is collapsed', rec.edge_id;
        CONTINUE; -- we don't want to spend time on it
      END IF;

      edgeseg = ST_MakeLine(p1, p2);

      -- Skip non-covered edges
      IF NOT ST_Equals(p2, ST_EndPoint(rec.geom)) THEN
        IF NOT ( _ST_Intersects(bounds, p1) AND _ST_Intersects(bounds, p2) )
        THEN
          --RAISE DEBUG 'Edge % has points % and % not intersecting with ring bounds', rec.edge_id, st_astext(p1), st_astext(p2);
          CONTINUE;
        END IF;
      ELSE
        -- must be a 2-points only edge, let's use Covers (more expensive)
        IF NOT _ST_Covers(bounds, edgeseg) THEN
          --RAISE DEBUG 'Edge % is not covered by ring', rec.edge_id;
          CONTINUE;
        END IF;
      END IF;

      p3 = ST_StartPoint(bounds);
      IF ST_DWithin(edgeseg, p3, 0) THEN
        -- Edge segment covers ring endpoint, See bug #874
        loc = ST_LineLocatePoint(edgeseg, p3);
        -- WARNING: this is as robust as length of edgeseg allows...
        IF loc > 0.9 THEN
          -- shift last point down 
          p2 = ST_LineInterpolatePoint(edgeseg, loc - 0.1);
        ELSIF loc < 0.1 THEN
          -- shift first point up
          p1 = ST_LineInterpolatePoint(edgeseg, loc + 0.1); 
        ELSE
          -- when ring start point is in between, we swap the points
          p3 = p1; p1 = p2; p2 = p3;
        END IF;
      END IF;

      right_side = ST_LineLocatePoint(bounds, p1) < 
                   ST_LineLocatePoint(bounds, p2);
  

      IF right_side THEN
        right_edges := array_append(right_edges, rec.edge_id);
        old_faceid = rec.right_face;
      ELSE
        left_edges := array_append(left_edges, rec.edge_id);
        old_faceid = rec.left_face;
      END IF;

      IF faceid IS NULL OR faceid = 0 THEN
        faceid = old_faceid;
        old_edgeid = rec.edge_id;
      ELSIF faceid != old_faceid THEN
        RAISE EXCEPTION 'Edge % has face % registered on the side of this face, while edge % has face % on the same side', rec.edge_id, old_faceid, old_edgeid, faceid;
      END IF;

      -- Collect all edges for final full coverage check
      all_edges = ST_Collect(all_edges, rec.geom);

    END LOOP; -- }
  END LOOP; -- }

  IF all_edges IS NULL THEN
    RAISE EXCEPTION 'Found no edges on the polygon boundary';
  END IF;


  --
  -- Check that all edges found, taken togheter,
  -- fully match the ring boundary and nothing more
  --
  -- If the test fail either we need to add more edges
  -- from the polygon ring or we need to split
  -- some of the existing ones.
  -- 
  bounds = ST_Boundary(apoly);
  IF NOT ST_isEmpty(ST_SymDifference(bounds, all_edges)) THEN
    IF NOT ST_isEmpty(ST_Difference(bounds, all_edges)) THEN
      RAISE EXCEPTION 'Polygon boundary is not fully defined by existing edges at or near point %', ST_AsText(ST_PointOnSurface(ST_Difference(bounds, all_edges)));
    ELSE
      RAISE EXCEPTION 'Existing edges cover polygon boundary and more at or near point % (invalid topology?)', ST_AsText(ST_PointOnSurface(ST_Difference(all_edges, bounds)));
    END IF;
  END IF;

  IF faceid IS NOT NULL AND faceid != 0 THEN
    IF NOT force_new THEN
      RETURN faceid;
    ELSE
    END IF;
  END IF;

  --
  -- Get new face id from sequence
  --
  FOR rec IN EXECUTE 'SELECT nextval(' ||
    quote_literal(
      quote_ident(atopology) || '.face_face_id_seq'
    ) || ')'
  LOOP
    faceid = rec.nextval;
  END LOOP;

  --
  -- Insert new face 
  --
  EXECUTE 'INSERT INTO '
    || quote_ident(atopology)
    || '.face(face_id, mbr) VALUES('
    -- face_id
    || faceid || ','
    -- minimum bounding rectangle
    || quote_literal(ST_Envelope(apoly)::text)
    || ')';

  --
  -- Update all edges having this face on the left
  --
  IF left_edges IS NOT NULL THEN
    EXECUTE 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET left_face = '
    || quote_literal(faceid)
    || ' WHERE edge_id = ANY('
    || quote_literal(left_edges)
    || ') ';
  END IF;

  --
  -- Update all edges having this face on the right
  --
  IF right_edges IS NOT NULL THEN
    EXECUTE 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET right_face = '
    || quote_literal(faceid)
    || ' WHERE edge_id = ANY('
    || quote_literal(right_edges)
    || ') ';
  END IF;


  --
  -- Set left_face/right_face of any contained edge 
  --
  EXECUTE 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET right_face = '
    || quote_literal(faceid)
    || ', left_face = '
    || quote_literal(faceid)
    || ' WHERE ST_Contains('
    || quote_literal(apoly::text)
    || ', geom)';

  -- 
  -- Set containing_face of any contained node 
  -- 
  EXECUTE 'UPDATE '
    || quote_ident(atopology)
    || '.node SET containing_face = '
    || quote_literal(faceid)
    || ' WHERE containing_face IS NOT NULL AND ST_Contains('
    || quote_literal(apoly::text)
    || ', geom)';

  RETURN faceid;
	
END
]]></definition>
</function>

<function name="topogeo_addpoint"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: toponame, apoint, tolerance - Adds a point to an existing topology using a tolerance and possibly splitting an existing edge.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true" default-value="0">
		<type name="character varying"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="tolerance" in="true">
		<type name="double precision"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  id integer;
  rec RECORD;
  sql text;
  prj GEOMETRY;
  snapedge GEOMETRY;
  snaptol FLOAT8;
  tol FLOAT8;
  z FLOAT8;
BEGIN

  -- 0. Check arguments
  IF geometrytype(apoint) != 'POINT' THEN
    RAISE EXCEPTION 'Invalid geometry type (%) passed to TopoGeo_AddPoint, expected POINT', geometrytype(apoint);
  END IF;

  -- Get tolerance, if 0 was given
  tol := COALESCE( NULLIF(tolerance, 0), topology._st_mintolerance(atopology, apoint) );

  -- 1. Check if any existing node is closer than the given precision
  --    and if so pick the closest
  sql := 'SELECT a.node_id FROM ' 
    || quote_ident(atopology) 
    || '.node as a WHERE ST_DWithin(a.geom,'
    || quote_literal(apoint::text) || '::geometry,'
    || tol || ') AND ST_Distance('
    || quote_literal(apoint::text)
    || '::geometry, a.geom) < ' || tol || ' ORDER BY ST_Distance('
    || quote_literal(apoint::text)
    || '::geometry, a.geom) LIMIT 1;';
  EXECUTE sql INTO id;
  IF id IS NOT NULL THEN
    RETURN id;
  END IF;


  -- 2. Check if any existing edge falls within tolerance
  --    and if so split it by a point projected on it
  sql := 'SELECT a.edge_id, a.geom FROM ' 
    || quote_ident(atopology) 
    || '.edge as a WHERE ST_DWithin(a.geom,'
    || quote_literal(apoint::text) || '::geometry,'
    || tol || ') ORDER BY ST_Distance('
    || quote_literal(apoint::text)
    || '::geometry, a.geom) LIMIT 1;';
  EXECUTE sql INTO rec;
  IF rec IS NOT NULL THEN
    -- project point to line, split edge by point
    prj := ST_ClosestPoint(rec.geom, apoint);
    -- This is a workaround for ClosestPoint lack of Z support:
    -- http://trac.osgeo.org/postgis/ticket/2033
    z := ST_Z(apoint);
    IF z IS NOT NULL THEN
      prj := ST_Translate(ST_Force_3DZ(prj), 0, 0, z); -- no ST_SetZ ...
    END IF;
    IF NOT ST_Contains(rec.geom, prj) THEN
      -- The tolerance must be big enough for snapping to happen
      -- and small enough to snap only to the projected point.
      -- Unfortunately ST_Distance returns 0 because it also uses
      -- a projected point internally, so we need another way.
      snaptol := topology._st_mintolerance(prj);
      snapedge := ST_Snap(rec.geom, prj, snaptol);

      -- Snapping currently snaps the first point below tolerance
      -- so may possibly move first point. See ticket #1631
      IF NOT ST_Equals(ST_StartPoint(rec.geom), ST_StartPoint(snapedge))
      THEN
        snapedge := ST_MakeLine(ST_StartPoint(rec.geom), snapedge);
      END IF;

      PERFORM ST_ChangeEdgeGeom(atopology, rec.edge_id, snapedge);
    END IF;
    id := topology.ST_ModEdgeSplit(atopology, rec.edge_id, prj);
  ELSE
    id := topology.ST_AddIsoNode(atopology, NULL, apoint);
  END IF;

  RETURN id;
END
]]></definition>
</function>

<function name="topogeo_addlinestring"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: toponame, aline, tolerance - Adds a linestring to an existing topology using a tolerance and possibly splitting existing edges/faces. Returns edge identifiers]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true" default-value="0">
		<type name="character varying"/>
	</parameter>
	<parameter name="aline" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="tolerance" in="true">
		<type name="double precision"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  rec2 RECORD;
  sql TEXT;
  set1 GEOMETRY;
  set2 GEOMETRY;
  snapped GEOMETRY;
  noded GEOMETRY;
  start_node INTEGER;
  end_node INTEGER;
  id INTEGER; 
  inodes GEOMETRY;
  iedges GEOMETRY;
  tol float8;
BEGIN

  -- 0. Check arguments
  IF geometrytype(aline) != 'LINESTRING' THEN
    RAISE EXCEPTION 'Invalid geometry type (%) passed to TopoGeo_AddLinestring, expected LINESTRING', geometrytype(aline);
  END IF;

  -- Get tolerance, if 0 was given
  tol := COALESCE( NULLIF(tolerance, 0), topology._st_mintolerance(atopology, aline) );

  -- 1. Self-node
  noded := ST_UnaryUnion(aline);

  -- 2. Node to edges falling within tol distance
  sql := 'WITH nearby AS ( SELECT e.geom FROM '
    || quote_ident(atopology) 
    || '.edge e WHERE ST_DWithin(e.geom, '
    || quote_literal(noded::text)
    || '::geometry, '
    || tol || ') ) SELECT st_collect(geom) FROM nearby;';
  EXECUTE sql INTO iedges;
  IF iedges IS NOT NULL THEN


    snapped := ST_Snap(noded, iedges, tol);

    noded := ST_Difference(snapped, iedges);

    set1 := ST_Intersection(snapped, iedges);

    set2 := ST_LineMerge(set1);

    noded := ST_Union(noded, set2);

  END IF;

  -- 2.1. Node with existing nodes within tol
  -- TODO: check if we should be only considering _isolated_ nodes!
  sql := 'WITH nearby AS ( SELECT n.geom FROM '
    || quote_ident(atopology) 
    || '.node n WHERE ST_DWithin(n.geom, '
    || quote_literal(noded::text)
    || '::geometry, '
    || tol || ') ) SELECT st_collect(geom) FROM nearby;';
  EXECUTE sql INTO inodes;

  IF inodes IS NOT NULL THEN -- {

    -- TODO: consider snapping once against all elements
    ---      (rather than once with edges and once with nodes)
    noded := ST_Snap(noded, inodes, tol);

    FOR rec IN SELECT (ST_Dump(inodes)).geom
    LOOP
        -- Use the node to split edges
        SELECT ST_Collect(geom) 
        FROM ST_Dump(ST_Split(noded, rec.geom))
        INTO STRICT noded;
    END LOOP;

    -- re-node to account for ST_Snap introduced self-intersections
    -- See http://trac.osgeo.org/postgis/ticket/1714
    -- TODO: consider running UnaryUnion once after all noding 
    noded := ST_UnaryUnion(noded);
  END IF; -- }

  -- 3. For each (now-noded) segment, insert an edge
  FOR rec IN SELECT (ST_Dump(noded)).geom LOOP

    -- TODO: skip point elements ?


    start_node := topology.TopoGeo_AddPoint(atopology,
                                          ST_StartPoint(rec.geom),
                                          tol);

    end_node := topology.TopoGeo_AddPoint(atopology,
                                        ST_EndPoint(rec.geom),
                                        tol);

    -- Added endpoints may have drifted due to tolerance, so
    -- we need to re-snap the edge to the new nodes before adding it
    sql := 'SELECT n1.geom as sn, n2.geom as en FROM ' || quote_ident(atopology)
      || '.node n1, ' || quote_ident(atopology)
      || '.node n2 WHERE n1.node_id = '
      || start_node || ' AND n2.node_id = ' || end_node;

    EXECUTE sql INTO STRICT rec2;

    snapped := ST_SetPoint(
                 ST_SetPoint(rec.geom, ST_NPoints(rec.geom)-1, rec2.en),
                 0, rec2.sn);

    
    snapped := ST_CollectionExtract(ST_MakeValid(snapped), 2);


    -- Check if the so-snapped edge collapsed (see #1650)
    IF ST_IsEmpty(snapped) THEN
      CONTINUE;
    END IF;

    -- Check if the so-snapped edge _now_ exists
    sql := 'SELECT edge_id FROM ' || quote_ident(atopology)
      || '.edge_data WHERE ST_Equals(geom, ' || quote_literal(snapped::text)
      || '::geometry)';
    EXECUTE sql INTO id;
    IF id IS NULL THEN
      id := topology.ST_AddEdgeModFace(atopology, start_node, end_node,
                                       snapped);
    ELSE
    END IF;

    RETURN NEXT id;

  END LOOP;

  RETURN;
END
]]></definition>
</function>

<function name="topogeo_addpolygon"
		window-func="false"
		returns-setof="true"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="1000">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, apoly, atolerance - Adds a polygon to an existing topology using a tolerance and possibly splitting existing edges/faces.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true" default-value="0">
		<type name="character varying"/>
	</parameter>
	<parameter name="apoly" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="tolerance" in="true">
		<type name="double precision"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  boundary GEOMETRY;
  fgeom GEOMETRY;
  rec RECORD;
  edges INTEGER[];
  sql TEXT;
  tol FLOAT8;
BEGIN

  -- 0. Check arguments
  IF geometrytype(apoly) != 'POLYGON' THEN
    RAISE EXCEPTION 'Invalid geometry type (%) passed to TopoGeo_AddPolygon, expected POLYGON', geometrytype(apoly);
  END IF;

  -- Get tolerance, if 0 was given
  tol := COALESCE( NULLIF(tolerance, 0), topology._st_mintolerance(atopology, apoly) );

  -- 1. Extract boundary
  boundary := ST_Boundary(apoly);

  -- 2. Add boundaries as edges
  FOR rec IN SELECT (ST_Dump(boundary)).geom LOOP
    edges := array_cat(edges, array_agg(x)) FROM ( select topology.TopoGeo_addLinestring(atopology, rec.geom, tol) as x ) as foo;
  END LOOP;

  -- 3. Find faces covered by input polygon
  --    NOTE: potential snapping changed polygon edges
  sql := 'SELECT DISTINCT f.face_id FROM ' || quote_ident(atopology)
    || '.face f WHERE f.mbr && '
    || quote_literal(apoly::text)
    || '::geometry';
  FOR rec IN EXECUTE sql LOOP
    -- check for actual containment
    fgeom := ST_PointOnSurface(ST_GetFaceGeometry(atopology, rec.face_id));
    IF NOT ST_Covers(apoly, fgeom) THEN
      CONTINUE;
    END IF;
    RETURN NEXT rec.face_id;
  END LOOP;

END
]]></definition>
</function>

<function name="topogeo_addgeometry"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="atopology" in="true" default-value="0">
		<type name="character varying"/>
	</parameter>
	<parameter name="ageom" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="tolerance" in="true">
		<type name="double precision"/>
	</parameter>
	<definition><![CDATA[
DECLARE
BEGIN
	RAISE EXCEPTION 'TopoGeo_AddGeometry not implemented yet';
END
]]></definition>
</function>

<function name="polygonize"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: toponame - Find and register all faces defined by topology edges]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  sql text;
  rec RECORD;
  faces int;
BEGIN

  sql := 'SELECT (st_dump(st_polygonize(geom))).geom from '
         || quote_ident(toponame) || '.edge_data';

  faces = 0;
  FOR rec in EXECUTE sql LOOP
    BEGIN
      PERFORM topology.AddFace(toponame, rec.geom);
      faces = faces + 1;
    EXCEPTION
      WHEN OTHERS THEN
        RAISE WARNING 'Error registering face % (%)', rec.geom, SQLERRM;
    END;
  END LOOP;
  RETURN faces || ' faces registered';
END
]]></definition>
</function>

<function name="_asgmlnode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="id" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="point" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="nsprefix_in" in="true">
		<type name="text"/>
	</parameter>
	<parameter name="prec" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="options" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="idprefix" in="true">
		<type name="text"/>
	</parameter>
	<parameter name="gmlver" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  nsprefix text;
  gml text;
BEGIN

  nsprefix := 'gml:';
  IF NOT nsprefix_in IS NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  gml := '<' || nsprefix || 'Node ' || nsprefix
    || 'id="' || idprefix || 'N' || id || '"';
  IF point IS NOT NULL THEN
    gml = gml || '>'
              || '<' || nsprefix || 'pointProperty>'
              || ST_AsGML(gmlver, point, prec, options, nsprefix_in)
              || '</' || nsprefix || 'pointProperty>'
              || '</' || nsprefix || 'Node>';
  ELSE
    gml = gml || '/>';
  END IF;
  RETURN gml;
END
]]></definition>
</function>

<function name="_asgmledge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="edge_id" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="start_node" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="end_node" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="line" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="visitedtable" in="true">
		<type name="regclass"/>
	</parameter>
	<parameter name="nsprefix_in" in="true">
		<type name="text"/>
	</parameter>
	<parameter name="prec" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="options" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="idprefix" in="true">
		<type name="text"/>
	</parameter>
	<parameter name="gmlver" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  visited bool;
  nsprefix text;
  gml text;
BEGIN

  nsprefix := 'gml:';
  IF nsprefix_in IS NOT NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  gml := '<' || nsprefix || 'Edge ' || nsprefix
    || 'id="' || idprefix || 'E' || edge_id || '">';

  -- Start node
  gml = gml || '<' || nsprefix || 'directedNode orientation="-"';
  -- Do visited bookkeeping if visitedTable was given
  visited = NULL;
  IF visitedTable IS NOT NULL THEN
    EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 1 AND element_id = '
            || start_node LIMIT 1 INTO visited;
    IF visited IS NOT NULL THEN
      gml = gml || ' xlink:href="#' || idprefix || 'N' || start_node || '" />';
    ELSE
      -- Mark as visited 
      EXECUTE 'INSERT INTO ' || visitedTable::text
        || '(element_type, element_id) VALUES (1, '
        || start_node || ')';
    END IF;
  END IF;
  IF visited IS NULL THEN
    gml = gml || '>';
    gml = gml || topology._AsGMLNode(start_node, NULL, nsprefix_in,
                                     prec, options, idprefix, gmlver);
    gml = gml || '</' || nsprefix || 'directedNode>';
  END IF;

  -- End node
  gml = gml || '<' || nsprefix || 'directedNode';
  -- Do visited bookkeeping if visitedTable was given
  visited = NULL;
  IF visitedTable IS NOT NULL THEN
    EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 1 AND element_id = '
            || end_node LIMIT 1 INTO visited;
    IF visited IS NOT NULL THEN
      gml = gml || ' xlink:href="#' || idprefix || 'N' || end_node || '" />';
    ELSE
      -- Mark as visited 
      EXECUTE 'INSERT INTO ' || visitedTable::text
        || '(element_type, element_id) VALUES (1, '
        || end_node || ')';
    END IF;
  END IF;
  IF visited IS NULL THEN
    gml = gml || '>';
    gml = gml || topology._AsGMLNode(end_node, NULL, nsprefix_in,
                                     prec, options, idprefix, gmlver);
    gml = gml || '</' || nsprefix || 'directedNode>';
  END IF;

  IF line IS NOT NULL THEN
    gml = gml || '<' || nsprefix || 'curveProperty>'
              || ST_AsGML(gmlver, line, prec, options, nsprefix_in)
              || '</' || nsprefix || 'curveProperty>';
  END IF;

  gml = gml || '</' || nsprefix || 'Edge>';

  RETURN gml;
END
]]></definition>
</function>

<function name="_asgmlface"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="text"/>
	</parameter>
	<parameter name="face_id" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="visitedtable" in="true">
		<type name="regclass"/>
	</parameter>
	<parameter name="nsprefix_in" in="true">
		<type name="text"/>
	</parameter>
	<parameter name="prec" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="options" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="idprefix" in="true">
		<type name="text"/>
	</parameter>
	<parameter name="gmlver" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  visited bool;
  nsprefix text;
  gml text;
  rec RECORD;
  rec2 RECORD;
  bounds geometry;
BEGIN

  nsprefix := 'gml:';
  IF nsprefix_in IS NOT NULL THEN
    IF nsprefix_in = '' THEN
      nsprefix = nsprefix_in;
    ELSE
      nsprefix = nsprefix_in || ':';
    END IF;
  END IF;

  gml := '<' || nsprefix || 'Face ' || nsprefix
    || 'id="' || idprefix || 'F' || face_id || '">';

  -- Construct the face geometry, then for each polygon:
  FOR rec IN SELECT (ST_DumpRings((ST_Dump(ST_ForceRHR(
    topology.ST_GetFaceGeometry(toponame, face_id)))).geom)).geom
  LOOP

      -- Contents of a directed face are the list of edges
      -- that cover the specific ring
      bounds = ST_Boundary(rec.geom);

      FOR rec2 IN EXECUTE
        'SELECT e.*, ST_LineLocatePoint('
        || quote_literal(bounds::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.2)) as pos'
        || ', ST_LineLocatePoint('
        || quote_literal(bounds::text)
        || ', ST_LineInterpolatePoint(e.geom, 0.8)) as pos2 FROM '
        || quote_ident(toponame)
        || '.edge e WHERE ( e.left_face = ' || face_id
        || ' OR e.right_face = ' || face_id
        || ') AND ST_Covers('
        || quote_literal(bounds::text)
        || ', e.geom) ORDER BY pos'
      LOOP

        gml = gml || '<' || nsprefix || 'directedEdge';

        -- if this edge goes in same direction to the
        --       ring bounds, make it with negative orientation
        IF rec2.pos2 > rec2.pos THEN -- edge goes in same direction
          gml = gml || ' orientation="-"';
        END IF;

        -- Do visited bookkeeping if visitedTable was given
        IF visitedTable IS NOT NULL THEN

          EXECUTE 'SELECT true FROM '
            || visitedTable::text
            || ' WHERE element_type = 2 AND element_id = '
            || rec2.edge_id LIMIT 1 INTO visited;
          IF visited THEN
            -- Use xlink:href if visited
            gml = gml || ' xlink:href="#' || idprefix || 'E'
                      || rec2.edge_id || '" />';
            CONTINUE;
          ELSE
            -- Mark as visited otherwise
            EXECUTE 'INSERT INTO ' || visitedTable::text
              || '(element_type, element_id) VALUES (2, '
              || rec2.edge_id || ')';
          END IF;

        END IF;

        gml = gml || '>';

        gml = gml || topology._AsGMLEdge(rec2.edge_id, rec2.start_node,
                                        rec2.end_node, rec2.geom,
                                        visitedTable, nsprefix_in,
                                        prec, options, idprefix, gmlver);
        gml = gml || '</' || nsprefix || 'directedEdge>';

      END LOOP;
    END LOOP;

  gml = gml || '</' || nsprefix || 'Face>';

  RETURN gml;
END
]]></definition>
</function>

<usertype name="getfaceedges_returntype" configuration="composite">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[postgis type: A composite type that consists of a sequence number and edge number. This is the return type for ST_GetFaceEdges]]></comment>
	<typeattrib name="sequence">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="edge">
		<type name="integer"/>
	</typeattrib>
</usertype>

<function name="st_newedgeheal"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anedge, anotheredge - Heal two edges by deleting the node connecting them, deleting both edges,and replacing them with an edge whose direction is the same as the firstedge provided.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="e1id" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="e2id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  e1rec RECORD;
  e2rec RECORD;
  rec RECORD;
  newedgeid int;
  connectededges int[];
  commonnode int;
  caseno int;
  topoid int;
  sql text;
  e2sign int;
  eidary int[];
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL OR e2id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- NOT IN THE SPECS: see if the same edge is given twice..
  IF e1id = e2id THEN
    RAISE EXCEPTION 'Cannot heal edge % with itself, try with another', e1id;
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e2id
      INTO STRICT e2rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e2id;
    -- NOTE: checks for INVALID_SCHEMA_NAME or UNDEFINED_TABLE done before
  END;


  -- NOT IN THE SPECS: See if any of the two edges are closed.
  IF e1rec.start_node = e1rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e1id, e2id;
  END IF;
  IF e2rec.start_node = e2rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e2id, e1id;
  END IF;

  -- Find common node

  IF e1rec.end_node = e2rec.start_node THEN
    commonnode = e1rec.end_node;
    caseno = 1;
  ELSIF e1rec.end_node = e2rec.end_node THEN
    commonnode = e1rec.end_node;
    caseno = 2;
  END IF;

  -- Check if any other edge is connected to the common node
  IF commonnode IS NOT NULL THEN
    FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
      || '.edge_data WHERE ( edge_id != ' || e1id
      || ' AND edge_id != ' || e2id || ') AND ( start_node = '
      || commonnode || ' OR end_node = ' || commonnode || ' )'
    LOOP
      commonnode := NULL;
      connectededges = connectededges || rec.edge_id;
    END LOOP;
  END IF;

  IF commonnode IS NULL THEN
    IF e1rec.start_node = e2rec.start_node THEN
      commonnode = e1rec.start_node;
      caseno = 3;
    ELSIF e1rec.start_node = e2rec.end_node THEN
      commonnode = e1rec.start_node;
      caseno = 4;
    END IF;

    -- Check if any other edge is connected to the common node
    IF commonnode IS NOT NULL THEN
      FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
        || '.edge_data WHERE ( edge_id != ' || e1id
        || ' AND edge_id != ' || e2id || ') AND ( start_node = '
        || commonnode || ' OR end_node = ' || commonnode || ' )'
      LOOP
        commonnode := NULL;
        connectededges = connectededges || rec.edge_id;
      END LOOP;
    END IF;
  END IF;

  IF commonnode IS NULL THEN
    IF connectededges IS NOT NULL THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - other edges connected (%)', array_to_string(connectededges, ',');
    ELSE
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-connected edges';
    END IF;
  END IF;

  -- NOT IN THE SPECS:
  -- check if any topo_geom is defined only by one of the
  -- input edges. In such case there would be no way to adapt
  -- the definition in case of healing, so we'd have to bail out
  eidary = ARRAY[e1id, e2id];
  sql := 'SELECT t.* from ('
    || 'SELECT r.topogeo_id, r.layer_id'
    || ', l.schema_name, l.table_name, l.feature_column'
    || ', array_agg(abs(r.element_id)) as elems '
    || 'FROM topology.layer l INNER JOIN '
    || quote_ident(toponame)
    || '.relation r ON (l.layer_id = r.layer_id) '
    || 'WHERE l.level = 0 AND l.feature_type = 2 '
    || ' AND l.topology_id = ' || topoid
    || ' AND abs(r.element_id) IN (' || e1id || ',' || e2id || ') '
    || 'group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
    || ' l.feature_column ) t WHERE NOT t.elems @> '
    || quote_literal(eidary);
  --RAISE DEBUG 'SQL: %', sql;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing edges % and %',
          rec.topogeo_id, rec.layer_id,
          rec.schema_name, rec.table_name, rec.feature_column,
          e1id, e2id;
  END LOOP;

  -- Create new edge {
  rec := e1rec;
  IF caseno = 1 THEN -- e1.end = e2.start
    rec.geom = ST_MakeLine(e1rec.geom, e2rec.geom);
    rec.end_node = e2rec.end_node;
    rec.next_left_edge = e2rec.next_left_edge;
    e2sign = 1;
  ELSIF caseno = 2 THEN -- e1.end = e2.end
    rec.geom = ST_MakeLine(e1rec.geom, st_reverse(e2rec.geom));
    rec.end_node = e2rec.start_node;
    rec.next_left_edge = e2rec.next_right_edge;
    e2sign = -1;
  ELSIF caseno = 3 THEN -- e1.start = e2.start
    rec.geom = ST_MakeLine(st_reverse(e2rec.geom), e1rec.geom);
    rec.start_node = e2rec.end_node;
    rec.next_right_edge = e2rec.next_left_edge;
    e2sign = -1;
  ELSIF caseno = 4 THEN -- e1.start = e2.end
    rec.geom = ST_MakeLine(e2rec.geom, e1rec.geom);
    rec.start_node = e2rec.start_node;
    rec.next_right_edge = e2rec.next_right_edge;
    e2sign = 1;
  END IF;
  -- }

  -- Insert new edge {
  EXECUTE 'SELECT nextval(' || quote_literal(
      quote_ident(toponame) || '.edge_data_edge_id_seq'
    ) || ')' INTO STRICT newedgeid;
  EXECUTE 'INSERT INTO ' || quote_ident(toponame)
    || '.edge VALUES(' || newedgeid
    || ',' || rec.start_node
    || ',' || rec.end_node
    || ',' || rec.next_left_edge
    || ',' || rec.next_right_edge
    || ',' || rec.left_face
    || ',' || rec.right_face
    || ',' || quote_literal(rec.geom::text)
    || ')';
  -- End of new edge insertion }

  -- Update next_left_edge/next_right_edge for
  -- any edge having them still pointing at the edges being removed
  -- (e2id)
  --
  -- NOTE:
  -- *(next_XXX_edge/e2id) serves the purpose of extracting existing
  -- sign from the value, while *e2sign changes that sign again if we
  -- reverted edge2 direction
  --
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || newedgeid
    || ', next_left_edge = ' || e2sign*newedgeid
    || '*(next_left_edge/'
    || e2id || ')  WHERE abs_next_left_edge = ' || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || newedgeid
    || ', next_right_edge = ' || e2sign*newedgeid
    || '*(next_right_edge/'
    || e2id || ') WHERE abs_next_right_edge = ' || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  -- New edge has the same direction as old edge 1
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || newedgeid
    || ', next_left_edge = ' || newedgeid
    || '*(next_left_edge/'
    || e1id || ')  WHERE abs_next_left_edge = ' || e1id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || newedgeid
    || ', next_right_edge = ' || newedgeid
    || '*(next_right_edge/'
    || e1id || ') WHERE abs_next_right_edge = ' || e1id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  --
  -- NOT IN THE SPECS:
  -- Replace composition rows involving the two
  -- edges as one involving the new edge.
  -- It takes a DELETE and an UPDATE to do all
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.relation r USING topology.layer l '
    || 'WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.relation r '
    || ' SET element_id = ' || newedgeid || '*(element_id/'
    || e1id
    || ') FROM topology.layer l WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e1id
  ;
  EXECUTE sql;


  -- Delete both edges
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e2id;
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;

  -- Delete the common node 
  BEGIN
    EXECUTE 'DELETE FROM ' || quote_ident(toponame)
            || '.node WHERE node_id = ' || commonnode;
    EXCEPTION
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing node table)',
          toponame;
  END;

  RETURN newedgeid;
END
]]></definition>
</function>

<function name="st_modedgeheal"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anedge, anotheredge - Heal two edges by deleting the node connecting them, modifying the first edgeand deleting the second edge. Returns the id of the deleted node.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="e1id" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="e2id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  e1rec RECORD;
  e2rec RECORD;
  rec RECORD;
  connectededges int[];
  commonnode int;
  caseno int;
  topoid int;
  sql text;
  e2sign int;
  eidary int[];
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL OR e2id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- NOT IN THE SPECS: see if the same edge is given twice..
  IF e1id = e2id THEN
    RAISE EXCEPTION 'Cannot heal edge % with itself, try with another', e1id;
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e2id
      INTO STRICT e2rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e2id;
    -- NOTE: checks for INVALID_SCHEMA_NAME or UNDEFINED_TABLE done before
  END;


  -- NOT IN THE SPECS: See if any of the two edges are closed.
  IF e1rec.start_node = e1rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e1id, e2id;
  END IF;
  IF e2rec.start_node = e2rec.end_node THEN
    RAISE EXCEPTION 'Edge % is closed, cannot heal to edge %', e2id, e1id;
  END IF;

  -- Find common node

  IF e1rec.end_node = e2rec.start_node THEN
    commonnode = e1rec.end_node;
    caseno = 1;
  ELSIF e1rec.end_node = e2rec.end_node THEN
    commonnode = e1rec.end_node;
    caseno = 2;
  END IF;

  -- Check if any other edge is connected to the common node
  IF commonnode IS NOT NULL THEN
    FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
      || '.edge_data WHERE ( edge_id != ' || e1id
      || ' AND edge_id != ' || e2id || ') AND ( start_node = '
      || commonnode || ' OR end_node = ' || commonnode || ' )'
    LOOP
      commonnode := NULL;
      connectededges = connectededges || rec.edge_id;
    END LOOP;
  END IF;

  IF commonnode IS NULL THEN
    IF e1rec.start_node = e2rec.start_node THEN
      commonnode = e1rec.start_node;
      caseno = 3;
    ELSIF e1rec.start_node = e2rec.end_node THEN
      commonnode = e1rec.start_node;
      caseno = 4;
    END IF;

    -- Check if any other edge is connected to the common node
    IF commonnode IS NOT NULL THEN
      FOR rec IN EXECUTE 'SELECT edge_id FROM ' || quote_ident(toponame)
        || '.edge_data WHERE ( edge_id != ' || e1id
        || ' AND edge_id != ' || e2id || ') AND ( start_node = '
        || commonnode || ' OR end_node = ' || commonnode || ' )'
      LOOP
        commonnode := NULL;
        connectededges = connectededges || rec.edge_id;
      END LOOP;
    END IF;
  END IF;

  IF commonnode IS NULL THEN
    IF connectededges IS NOT NULL THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - other edges connected (%)', array_to_string(connectededges, ',');
    ELSE
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-connected edges';
    END IF;
  END IF;

  -- NOT IN THE SPECS:
  -- check if any topo_geom is defined only by one of the
  -- input edges. In such case there would be no way to adapt
  -- the definition in case of healing, so we'd have to bail out
  eidary = ARRAY[e1id, e2id];
  sql := 'SELECT t.* from ('
    || 'SELECT r.topogeo_id, r.layer_id'
    || ', l.schema_name, l.table_name, l.feature_column'
    || ', array_agg(abs(r.element_id)) as elems '
    || 'FROM topology.layer l INNER JOIN '
    || quote_ident(toponame)
    || '.relation r ON (l.layer_id = r.layer_id) '
    || 'WHERE l.level = 0 AND l.feature_type = 2 '
    || ' AND l.topology_id = ' || topoid
    || ' AND abs(r.element_id) IN (' || e1id || ',' || e2id || ') '
    || 'group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
    || ' l.feature_column ) t WHERE NOT t.elems @> '
    || quote_literal(eidary);
  --RAISE DEBUG 'SQL: %', sql;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing edges % and %',
          rec.topogeo_id, rec.layer_id,
          rec.schema_name, rec.table_name, rec.feature_column,
          e1id, e2id;
  END LOOP;

  -- Update data of the first edge {
  rec := e1rec;
  IF caseno = 1 THEN -- e1.end = e2.start
    rec.geom = ST_MakeLine(e1rec.geom, e2rec.geom);
    rec.end_node = e2rec.end_node;
    rec.next_left_edge = e2rec.next_left_edge;
    e2sign = 1;
  ELSIF caseno = 2 THEN -- e1.end = e2.end
    rec.geom = ST_MakeLine(e1rec.geom, st_reverse(e2rec.geom));
    rec.end_node = e2rec.start_node;
    rec.next_left_edge = e2rec.next_right_edge;
    e2sign = -1;
  ELSIF caseno = 3 THEN -- e1.start = e2.start
    rec.geom = ST_MakeLine(st_reverse(e2rec.geom), e1rec.geom);
    rec.start_node = e2rec.end_node;
    rec.next_right_edge = e2rec.next_left_edge;
    e2sign = -1;
  ELSIF caseno = 4 THEN -- e1.start = e2.end
    rec.geom = ST_MakeLine(e2rec.geom, e1rec.geom);
    rec.start_node = e2rec.start_node;
    rec.next_right_edge = e2rec.next_right_edge;
    e2sign = 1;
  END IF;
  EXECUTE 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET geom = ' || quote_literal(rec.geom::text)
    || ', start_node = ' || rec.start_node
    || ', end_node = ' || rec.end_node
    || ', next_left_edge = ' || rec.next_left_edge
    || ', abs_next_left_edge = ' || abs(rec.next_left_edge)
    || ', next_right_edge = ' || rec.next_right_edge
    || ', abs_next_right_edge = ' || abs(rec.next_right_edge)
    || ' WHERE edge_id = ' || e1id;
  -- End of first edge update }

  -- Update next_left_edge/next_right_edge for
  -- any edge having them still pointing at the edge being removed (e2id)
  --
  -- NOTE:
  -- *(next_XXX_edge/e2id) serves the purpose of extracting existing
  -- sign from the value, while *e2sign changes that sign again if we
  -- reverted edge2 direction
  --
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_left_edge = ' || e1id
    || ', next_left_edge = ' || e2sign*e1id
    || '*(next_left_edge/'
    || e2id || ')  WHERE abs_next_left_edge = ' || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET abs_next_right_edge = ' || e1id
    || ', next_right_edge = ' || e2sign*e1id
    || '*(next_right_edge/'
    || e2id || ') WHERE abs_next_right_edge = ' || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  -- Delete the second edge
  EXECUTE 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e2id;

  -- Delete the common node 
  BEGIN
    EXECUTE 'DELETE FROM ' || quote_ident(toponame)
            || '.node WHERE node_id = ' || commonnode;
    EXCEPTION
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing node table)',
          toponame;
  END;

  --
  -- NOT IN THE SPECS:
  -- Drop composition rows involving second
  -- edge, as the first edge took its space,
  -- and all affected TopoGeom have been previously checked
  -- for being composed by both edges.
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.relation r USING topology.layer l '
    || 'WHERE l.level = 0 AND l.feature_type = 2'
    || ' AND l.topology_id = ' || topoid
    || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
    || e2id;
  --RAISE DEBUG 'SQL: %', sql;
  EXECUTE sql;

  RETURN commonnode;
END
]]></definition>
</function>

<function name="st_remedgenewface"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anedge - Removes an edge and, if the removed edge separated two faces,delete the original faces and replace them with a new face.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="e1id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  e1rec RECORD;
  rec RECORD;
  fidary int[];
  topoid int;
  sql text;
  newfaceid int;
  newfacecreated bool;
  elink int;
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  -- NOT IN THE SPECS:
  -- Check that no TopoGeometry references the edge being removed
  PERFORM topology._ST_RemEdgeCheck(toponame, topoid, e1id, e1rec.left_face, e1rec.right_face);

  -- Update next_left_edge and next_right_edge face
  -- for all edges bounding the new face
  RAISE NOTICE 'Updating next_{right,left}_face of ring edges...';

  -- TODO: reduce the following to 2 UPDATE rather than 4

  -- Update next_left_edge of previous edges in left face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge < 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge > 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  -- Update next_right_edge of previous edges in right face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge < 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge > 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  IF e1rec.left_face = e1rec.right_face THEN -- {

    newfaceid := e1rec.left_face; -- TODO: or what should we return ?
    newfacecreated := false;

  ELSE -- }{

    IF e1rec.left_face = 0 OR e1rec.right_face = 0 THEN -- {

      --
      -- We won't add any new face, but rather let the universe
      -- flood the removed face.
      --

      newfaceid := 0;
      newfacecreated := false;

    ELSE -- }{

      --
      -- Insert the new face 
      --

      sql := 'SELECT nextval(' || quote_literal(
          quote_ident(toponame) || '.face_face_id_seq'
        ) || ')';

      EXECUTE sql INTO STRICT newfaceid;
      newfacecreated := true;

      sql := 'INSERT INTO '
        || quote_ident(toponame)
        || '.face(face_id, mbr) SELECT '
        -- face_id
        || newfaceid  || ', '
        -- minimum bounding rectangle is the union of the old faces mbr
        -- (doing this without GEOS would be faster)
        || 'ST_Envelope(ST_Union(mbr)) FROM '
        || quote_ident(toponame)
        || '.face WHERE face_id IN (' 
        || e1rec.left_face || ',' || e1rec.right_face 
        || ')';
      EXECUTE sql;

    END IF; -- }

    -- Update left_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET left_face = ' || newfaceid 
      || ' WHERE left_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update right_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET right_face = ' || newfaceid 
      || ' WHERE right_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update containing_face for all nodes still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.node SET containing_face = ' || newfaceid 
      || ' WHERE containing_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- NOT IN THE SPECS:
    -- Replace composition rows involving the two
    -- faces as one involving the new face.
    -- It takes a DELETE and an UPDATE to do all
    sql := 'DELETE FROM ' || quote_ident(toponame)
      || '.relation r USING topology.layer l '
      || 'WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND abs(r.element_id) = '
      || e1rec.left_face;
    EXECUTE sql;
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.relation r '
      || ' SET element_id = ' || newfaceid 
      || ' FROM topology.layer l WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND r.element_id = '
      || e1rec.right_face;
    EXECUTE sql;

  END IF; -- } two faces healed...

  -- Delete the edge
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;
  EXECUTE sql;

  -- Check if any of the edge nodes remains isolated, 
  -- set containing_face  = newfaceid in that case
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.node n SET containing_face = ' || newfaceid
    || ' WHERE node_id IN ('
    || e1rec.start_node || ','
    || e1rec.end_node || ') AND NOT EXISTS (SELECT edge_id FROM '
    || quote_ident(toponame)
    || '.edge_data WHERE start_node = n.node_id OR end_node = n.node_id)';
  EXECUTE sql;

  IF e1rec.right_face != e1rec.left_face THEN -- {

    -- Delete left face, if not universe
    IF e1rec.left_face != 0 THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.left_face; 
      EXECUTE sql;
    END IF;

    -- Delete right face, if not universe
    IF e1rec.right_face != 0
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.right_face;
      EXECUTE sql;
    END IF;

  END IF; -- }

  IF newfacecreated THEN
    RETURN newfaceid;
  ELSE
    RETURN NULL; -- -newfaceid;
  END IF;
END
]]></definition>
</function>

<function name="st_remedgemodface"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anedge - Removes an edge and, if the removed edge separated two faces,delete one of the them and modify the other to take the space of both.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="e1id" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  e1rec RECORD;
  rec RECORD;
  fidary int[];
  topoid int;
  sql text;
  floodfaceid int;
  elink int;
BEGIN
  --
  -- toponame and face_id are required
  -- 
  IF toponame IS NULL OR e1id IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = toponame;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(toponame)
      || '.edge_data WHERE edge_id = ' || e1id
      INTO STRICT e1rec;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', e1id;
      WHEN INVALID_SCHEMA_NAME THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
      WHEN UNDEFINED_TABLE THEN
        RAISE EXCEPTION 'corrupted topology "%" (missing edge_data table)',
          toponame;
  END;

  -- NOT IN THE SPECS:
  -- Check that no TopoGeometry references the edge being removed
  PERFORM topology._ST_RemEdgeCheck(toponame, topoid, e1id, e1rec.left_face, e1rec.right_face);

  -- Update next_left_edge and next_right_edge face
  -- for all edges bounding the new face
  RAISE NOTICE 'Updating next_{right,left}_face of ring edges...';

  -- TODO: reduce the following to 2 UPDATE rather than 4

  -- Update next_left_edge of previous edges in left face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge < 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_left_edge = '
    || elink
    || ', abs_next_left_edge = '
    || abs(elink)
    || ' WHERE next_left_edge > 0 AND abs(next_left_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  -- Update next_right_edge of previous edges in right face -- {

  elink := e1rec.next_left_edge;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge < 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- If the edge being removed links to self,
  -- we use the other face
  IF e1rec.abs_next_right_edge = e1rec.edge_id THEN
    elink := e1rec.next_left_edge;
  ELSE
    elink := e1rec.next_right_edge;
  END IF;

  sql := 'UPDATE ' || quote_ident(toponame)
    || '.edge_data SET next_right_edge = '
    || elink
    || ', abs_next_right_edge = '
    || abs(elink)
    || ' WHERE next_right_edge > 0 AND abs(next_right_edge) = '
    || e1id;
  EXECUTE sql;

  -- }

  IF e1rec.left_face = e1rec.right_face THEN -- {

    floodfaceid = e1rec.left_face; 

  ELSE -- }{

    IF e1rec.left_face = 0 OR e1rec.right_face = 0 THEN -- {

      --
      -- We won't add any new face, but rather let the universe
      -- flood the removed face.
      --

      floodfaceid = 0;

    ELSE -- }{

      -- we choose right face as the face that will remain
      -- to be symmetric with ST_AddEdgeModFace 
      floodfaceid = e1rec.right_face;

      sql := 'UPDATE '
        || quote_ident(toponame)
        || '.face SET mbr = (SELECT '
        -- minimum bounding rectangle is the union of the old faces mbr
        -- (doing this without GEOS would be faster)
        || 'ST_Envelope(ST_Union(mbr)) FROM '
        || quote_ident(toponame)
        || '.face WHERE face_id IN (' 
        || e1rec.left_face || ',' || e1rec.right_face 
        || ') ) WHERE face_id = ' || floodfaceid ;
      EXECUTE sql;

    END IF; -- }

    -- Update left_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET left_face = ' || floodfaceid 
      || ' WHERE left_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update right_face for all edges still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.edge_data SET right_face = ' || floodfaceid 
      || ' WHERE right_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- Update containing_face for all nodes still referencing old faces
    sql := 'UPDATE ' || quote_ident(toponame)
      || '.node SET containing_face = ' || floodfaceid 
      || ' WHERE containing_face IN ('
      || e1rec.left_face || ',' || e1rec.right_face 
      || ')';
    EXECUTE sql;

    -- NOT IN THE SPECS:
    -- Replace composition rows involving the two
    -- faces as one involving the new face.
    -- It takes a single DELETE to do that.
    sql := 'DELETE FROM ' || quote_ident(toponame)
      || '.relation r USING topology.layer l '
      || 'WHERE l.level = 0 AND l.feature_type = 3'
      || ' AND l.topology_id = ' || topoid
      || ' AND l.layer_id = r.layer_id AND abs(r.element_id) IN ('
      || e1rec.left_face || ',' || e1rec.right_face
      || ') AND abs(r.element_id) != '
      || floodfaceid; -- could be optimized..
    EXECUTE sql;

  END IF; -- } two faces healed...

  -- Delete the edge
  sql := 'DELETE FROM ' || quote_ident(toponame)
    || '.edge_data WHERE edge_id = ' || e1id;
  EXECUTE sql;

  -- Check if any of the edge nodes remains isolated, 
  -- set containing_face  = floodfaceid in that case
  sql := 'UPDATE ' || quote_ident(toponame)
    || '.node n SET containing_face = ' || floodfaceid
    || ' WHERE node_id IN ('
    || e1rec.start_node || ','
    || e1rec.end_node || ') AND NOT EXISTS (SELECT edge_id FROM '
    || quote_ident(toponame)
    || '.edge_data WHERE start_node = n.node_id OR end_node = n.node_id)';
  EXECUTE sql;

  IF e1rec.right_face != e1rec.left_face THEN -- {

    -- Delete left face, if not universe and not "flood" face
    IF e1rec.left_face != 0 AND e1rec.left_face != floodfaceid
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.left_face; 
      EXECUTE sql;
    END IF;

    -- Delete right face, if not universe and not "flood" face
    IF e1rec.right_face != 0 AND e1rec.right_face != floodfaceid
    THEN
      sql := 'DELETE FROM ' || quote_ident(toponame)
        || '.face WHERE face_id = ' || e1rec.right_face;
      EXECUTE sql;
    END IF;

  END IF; -- }

  RETURN floodfaceid;
END
]]></definition>
</function>

<function name="st_getfacegeometry"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, aface - Returns the polygon in the given topology with the specified face id.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="toponame" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="aface" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  sql TEXT;
BEGIN

  --
  -- toponame and aface are required
  -- 
  IF toponame IS NULL OR aface IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  IF NOT EXISTS(SELECT name FROM topology WHERE name = toponame)  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END IF;

  IF aface = 0 THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - universal face has no geometry';
  END IF;

  BEGIN

    -- No such face
    sql := 'SELECT NOT EXISTS (SELECT * from ' || quote_ident(toponame)
      || '.face WHERE face_id = ' || aface
      || ') as none';
    EXECUTE sql INTO rec;
    IF rec.none THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent face.';
    END IF;

    --
    -- Construct face 
    -- 
    sql :=
      'SELECT ST_BuildArea(ST_Collect(geom)) as geom FROM '
      || quote_ident(toponame)
      || '.edge_data WHERE left_face = ' || aface
      || ' OR right_face = ' || aface;
    FOR rec IN EXECUTE sql
    LOOP
      RETURN rec.geom;
    END LOOP;

  EXCEPTION
    WHEN INVALID_SCHEMA_NAME THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
    WHEN UNDEFINED_TABLE THEN
      RAISE EXCEPTION 'corrupted topology "%"', toponame;
  END;

  RETURN NULL;
END
]]></definition>
</function>

<function name="st_addisonode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, aface, apoint - Adds an isolated node to a face in a topology and returns the nodeid of the new node. If face is null, the node is still created.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="aface" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  nodeid integer;
  sql text;
  containingface integer;
BEGIN

  --
  -- Atopology and apoint are required
  -- 
  IF atopology IS NULL OR apoint IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

      --
  -- Atopology must  be registered
  -- 
  IF NOT EXISTS(SELECT name FROM topology WHERE topology.name = atopology) THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid topology name';
  END IF;
  --
  -- Apoint must be a point
  --
  IF substring(geometrytype(apoint), 1, 5) != 'POINT'
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid point';
  END IF;

  --
  -- Check if a coincident node already exists
  -- 
  -- We use index AND x/y equality
  --
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node ' ||
    'WHERE ST_Equals(geom, ' || quote_literal(apoint::text) || '::geometry)'
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - coincident node';
  END LOOP;

  --
  -- Check if any edge crosses (intersects) this node
  -- I used _intersects_ here to include boundaries (endpoints)
  --
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge ' 
    || 'WHERE ST_Intersects(geom, ' || quote_literal(apoint::text)
    || '::geometry)'
  LOOP
    RAISE EXCEPTION
    'SQL/MM Spatial exception - edge crosses node.';
  END LOOP;

  -- retrieve the face that contains (eventually) the point
  
  --
  -- first test is to check if there is inside an mbr (more fast)
  --
  sql := 'SELECT f.face_id FROM ' 
        || quote_ident(atopology) 
        || '.face f WHERE f.face_id > 0 AND f.mbr && '
        || quote_literal(apoint::text)
        || '::geometry AND ST_Contains(topology.ST_GetFaceGeometry('
        || quote_literal(atopology) 
        || ', f.face_id), '
        || quote_literal(apoint::text)
        || '::geometry)';
  IF aface IS NOT NULL AND aface != 0 THEN
    sql := sql || ' AND f.face_id = ' || aface;
  END IF;

  EXECUTE sql INTO containingface;

  -- If aface was specified, check that it was correct
  IF aface IS NOT NULL THEN -- {
    IF aface = 0 THEN -- {
      IF containingface IS NOT NULL THEN -- {
        RAISE EXCEPTION
          'SQL/MM Spatial exception - within face % (not universe)',
          containingface;
      ELSE -- }{
        containingface := 0;
      END IF; -- }
    ELSE -- }{ -- aface != 0
      IF containingface IS NULL OR containingface != aface THEN -- {
        RAISE EXCEPTION 'SQL/MM Spatial exception - not within face';
      END IF; -- }
    END IF; -- }
  ELSE -- }{ -- aface is null
    containingface := COALESCE(containingface, 0);
  END IF; -- }

  --
  -- Insert the new row
  --
  sql := 'INSERT INTO '
      || quote_ident(atopology)
      || '.node(node_id, geom, containing_face) SELECT nextval('
      || quote_literal( quote_ident(atopology) || '.node_node_id_seq' )
      || '),'
      ||quote_literal(apoint::text)
      || '::geometry,' || containingface
      || ' RETURNING node_id';

  EXECUTE sql INTO nodeid;

  RETURN nodeid;
EXCEPTION
  -- TODO: avoid the EXCEPTION handling here ?
  WHEN INVALID_SCHEMA_NAME THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
END
]]></definition>
</function>

<function name="st_moveisonode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anedge, apoint - Moves an isolated node in a topology from one point to another. If new apoint geometry exists as a node an error is thrown. REturns description of move.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anode" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
BEGIN

  --
  -- All arguments are required
  -- 
  IF atopology IS NULL OR anode IS NULL OR apoint IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Apoint must be a point
  --
  IF substring(geometrytype(apoint), 1, 5) != 'POINT'
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid point';
  END IF;

  --
  -- Check node isolation.
  -- 
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge ' ||
    ' WHERE start_node =  ' || anode ||
    ' OR end_node = ' || anode 
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - not isolated node';
  END LOOP;

  --
  -- Check if a coincident node already exists
  -- 
  -- We use index AND x/y equality
  --
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node ' ||
    'WHERE geom && ' || quote_literal(apoint::text) || '::geometry'
    ||' AND ST_X(geom) = ST_X('||quote_literal(apoint::text)||'::geometry)'
    ||' AND ST_Y(geom) = ST_Y('||quote_literal(apoint::text)||'::geometry)'
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - coincident node';
  END LOOP;

  --
  -- Check if any edge crosses (intersects) this node
  -- I used _intersects_ here to include boundaries (endpoints)
  --
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge ' 
    || 'WHERE geom && ' || quote_literal(apoint::text) 
    || ' AND ST_Intersects(geom, ' || quote_literal(apoint::text)
    || '::geometry)'
  LOOP
    RAISE EXCEPTION
    'SQL/MM Spatial exception - edge crosses node.';
  END LOOP;

  --
  -- Update node point
  --
  EXECUTE 'UPDATE ' || quote_ident(atopology) || '.node '
    || ' SET geom = ' || quote_literal(apoint::text) 
    || ' WHERE node_id = ' || anode;

  RETURN 'Isolated Node ' || anode || ' moved to location '
    || ST_X(apoint) || ',' || ST_Y(apoint);
END
]]></definition>
</function>

<function name="st_removeisonode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anode - Removes an isolated node and returns description of action. If the node is not isolated (is start or end of an edge), then an exception is thrown.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anode" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
BEGIN

  --
  -- Atopology and apoint are required
  -- 
  IF atopology IS NULL OR anode IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Check node isolation.
  -- 
  FOR rec IN EXECUTE 'SELECT edge_id FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE start_node =  ' || anode ||
    ' OR end_node = ' || anode 
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - not isolated node';
  END LOOP;

  EXECUTE 'DELETE FROM ' || quote_ident(atopology) || '.node '
    || ' WHERE node_id = ' || anode;

  RETURN 'Isolated node ' || anode || ' removed';
END
]]></definition>
</function>

<function name="st_remisonode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
  SELECT topology.ST_RemoveIsoNode($1, $2)
]]></definition>
</function>

<function name="st_removeisoedge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anedge" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  edge RECORD;
  rec RECORD;
  ok BOOL;
BEGIN

  --
  -- Atopology and anedge are required
  -- 
  IF atopology IS NULL OR anedge IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Check node existance
  -- 
  ok = false;
  FOR edge IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE edge_id =  ' || anedge
  LOOP
    ok = true;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - non-existent edge';
  END IF;

  --
  -- Check node isolation
  -- 
  IF edge.left_face != edge.right_face THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - not isolated edge';
  END IF;

  FOR rec IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' 
    || ' WHERE edge_id !=  ' || anedge
    || ' AND ( start_node = ' || edge.start_node
    || ' OR start_node = ' || edge.end_node
    || ' OR end_node = ' || edge.start_node
    || ' OR end_node = ' || edge.end_node
    || ' ) '
  LOOP
    RAISE EXCEPTION
      'SQL/MM Spatial exception - not isolated edge';
  END LOOP;

  --
  -- Delete the edge
  --
  EXECUTE 'DELETE FROM ' || quote_ident(atopology) || '.edge_data '
    || ' WHERE edge_id = ' || anedge;

  RETURN 'Isolated edge ' || anedge || ' removed';
END
]]></definition>
</function>

<function name="st_newedgessplit"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anedge, apoint - Split an edge by creating a new node along an existing edge, deleting the original edge and replacing it with two new edges. Returns the id of the new node created that joins the new edges.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anedge" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  oldedge RECORD;
  rec RECORD;
  tmp integer;
  topoid integer;
  nodeid integer;
  nodepos float8;
  edgeid1 integer;
  edgeid2 integer;
  edge1 geometry;
  edge2 geometry;
  ok BOOL;
BEGIN

  --
  -- All args required
  -- 
  IF atopology IS NULL OR anedge IS NULL OR apoint IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;
  
  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = atopology;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  --
  -- Check node existance
  -- 
  ok = false;
  FOR oldedge IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE edge_id =  ' || anedge
  LOOP
    ok = true;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - non-existent edge';
  END IF;

  --
  -- Check that given point is Within(anedge.geom)
  -- 
  IF NOT ST_Within(apoint, oldedge.geom) THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - point not on edge';
  END IF;

  --
  -- Check if a coincident node already exists
  --
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node '
    || 'WHERE geom && '
    || quote_literal(apoint::text) || '::geometry'
    || ' AND ST_X(geom) = ST_X('
    || quote_literal(apoint::text) || '::geometry)'
    || ' AND ST_Y(geom) = ST_Y('
    || quote_literal(apoint::text) || '::geometry)'
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - coincident node';
  END LOOP;

  --
  -- Get new node id
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.node_node_id_seq'')'
  LOOP
    nodeid = rec.nextval;
  END LOOP;

  --RAISE NOTICE 'Next node id = % ', nodeid;

  --
  -- Add the new node 
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.node(node_id, geom) 
    VALUES(' || nodeid || ','
    || quote_literal(apoint::text)
    || ')';

  --
  -- Delete the old edge
  --
  EXECUTE 'DELETE FROM ' || quote_ident(atopology) || '.edge_data '
    || ' WHERE edge_id = ' || anedge;

  --
  -- Compute new edges
  --
  edge2 := ST_Split(oldedge.geom, apoint);
  edge1 := ST_GeometryN(edge2, 1);
  edge2 := ST_GeometryN(edge2, 2);

  --
  -- Get ids for the new edges 
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.edge_data_edge_id_seq'')'
  LOOP
    edgeid1 = rec.nextval;
  END LOOP;
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.edge_data_edge_id_seq'')'
  LOOP
    edgeid2 = rec.nextval;
  END LOOP;


  --RAISE NOTICE 'EdgeId1 % EdgeId2 %', edgeid1, edgeid2;

  --RAISE DEBUG 'oldedge.next_left_edge: %', oldedge.next_left_edge;
  --RAISE DEBUG 'oldedge.next_right_edge: %', oldedge.next_right_edge;

  --
  -- Insert the two new edges
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.edge VALUES('
    || edgeid1                                -- edge_id
    || ',' || oldedge.start_node              -- start_node
    || ',' || nodeid                          -- end_node
    || ',' || edgeid2                         -- next_left_edge
    || ',' || CASE                            -- next_right_edge
               WHEN 
                oldedge.next_right_edge = anedge
               THEN edgeid1
               WHEN
                oldedge.next_right_edge = -anedge
               THEN -edgeid2
               ELSE oldedge.next_right_edge
              END
    || ',' || oldedge.left_face               -- left_face
    || ',' || oldedge.right_face              -- right_face
    || ',' || quote_literal(edge1::text)      -- geom
    ||')';

  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.edge VALUES('
    || edgeid2                                -- edge_id
    || ',' || nodeid                          -- start_node
    || ',' || oldedge.end_node                -- end_node
    || ',' || CASE                            -- next_left_edge
               WHEN 
                oldedge.next_left_edge =
                -anedge
               THEN -edgeid2
               WHEN 
                oldedge.next_left_edge =
                anedge
               THEN edgeid1
               ELSE oldedge.next_left_edge
              END
    || ',' || -edgeid1                        -- next_right_edge
    || ',' || oldedge.left_face               -- left_face
    || ',' || oldedge.right_face              -- right_face
    || ',' || quote_literal(edge2::text)      -- geom
    ||')';

  --
  -- Update all next edge references to match new layout
  --

  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET next_right_edge = '
    || edgeid2
    || ','
    || ' abs_next_right_edge = ' || edgeid2
    || ' WHERE next_right_edge = ' || anedge
    || ' AND edge_id NOT IN (' || edgeid1 || ',' || edgeid2 || ')'
    ;
  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET next_right_edge = '
    || -edgeid1
    || ','
    || ' abs_next_right_edge = ' || edgeid1
    || ' WHERE next_right_edge = ' || -anedge
    || ' AND edge_id NOT IN (' || edgeid1 || ',' || edgeid2 || ')'
    ;

  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET next_left_edge = '
    || edgeid1
    || ','
    || ' abs_next_left_edge = ' || edgeid1
    || ' WHERE next_left_edge = ' || anedge
    || ' AND edge_id NOT IN (' || edgeid1 || ',' || edgeid2 || ')'
    ;
  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET '
    || ' next_left_edge = ' || -edgeid2
    || ','
    || ' abs_next_left_edge = ' || edgeid2
    || ' WHERE next_left_edge = ' || -anedge
    || ' AND edge_id NOT IN (' || edgeid1 || ',' || edgeid2 || ')'
    ;

  --
  -- Update references in the Relation table.
  -- We only take into considerations non-hierarchical
  -- TopoGeometry here, for obvious reasons.
  --
  FOR rec IN EXECUTE 'SELECT r.* FROM '
    || quote_ident(atopology)
    || '.relation r, topology.layer l '
    || ' WHERE '
    || ' l.topology_id = ' || topoid
    || ' AND l.level = 0 '
    || ' AND l.layer_id = r.layer_id '
    || ' AND abs(r.element_id) = ' || anedge
    || ' AND r.element_type = 2'
  LOOP
    --RAISE NOTICE 'TopoGeometry % in layer % contains the edge being split', rec.topogeo_id, rec.layer_id;

    -- Delete old reference
    EXECUTE 'DELETE FROM ' || quote_ident(atopology)
      || '.relation '
      || ' WHERE '
      || 'layer_id = ' || rec.layer_id
      || ' AND '
      || 'topogeo_id = ' || rec.topogeo_id
      || ' AND '
      || 'element_type = ' || rec.element_type
      || ' AND '
      || 'abs(element_id) = ' || anedge;

    -- Add new reference to edge1
    IF rec.element_id < 0 THEN
      tmp = -edgeid1;
    ELSE
      tmp = edgeid1;
    END IF;
    EXECUTE 'INSERT INTO ' || quote_ident(atopology)
      || '.relation '
      || ' VALUES( '
      || rec.topogeo_id
      || ','
      || rec.layer_id
      || ','
      || tmp
      || ','
      || rec.element_type
      || ')';

    -- Add new reference to edge2
    IF rec.element_id < 0 THEN
      tmp = -edgeid2;
    ELSE
      tmp = edgeid2;
    END IF;
    EXECUTE 'INSERT INTO ' || quote_ident(atopology)
      || '.relation '
      || ' VALUES( '
      || rec.topogeo_id
      || ','
      || rec.layer_id
      || ','
      || tmp
      || ','
      || rec.element_type
      || ')';
      
  END LOOP;

  --RAISE NOTICE 'Edge % split in edges % and % by node %',
  --  anedge, edgeid1, edgeid2, nodeid;

  RETURN nodeid; 
END
]]></definition>
</function>

<function name="st_modedgesplit"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anedge, apoint - Split an edge by creating a new node along an existing edge, modifying the original edge and adding a new edge.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anedge" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="apoint" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  oldedge RECORD;
  rec RECORD;
  tmp integer;
  topoid integer;
  nodeid integer;
  nodepos float8;
  newedgeid integer;
  newedge1 geometry;
  newedge2 geometry;
  query text;
  ok BOOL;
BEGIN

  --
  -- All args required
  -- 
  IF atopology IS NULL OR anedge IS NULL OR apoint IS NULL THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology id
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = atopology;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  --
  -- Check node existance
  -- 
  ok = false;
  FOR oldedge IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data ' ||
    ' WHERE edge_id =  ' || anedge
  LOOP
    ok = true;
  END LOOP;
  IF NOT ok THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - non-existent edge';
  END IF;

  --
  -- Check that given point is Within(anedge.geom)
  -- 
  IF NOT ST_Within(apoint, oldedge.geom) THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - point not on edge';
  END IF;

  --
  -- Check if a coincident node already exists
  --
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node ' ||
    'WHERE geom && '
    || quote_literal(apoint::text) || '::geometry'
    ||' AND ST_X(geom) = ST_X('
    || quote_literal(apoint::text) || '::geometry)'
    ||' AND ST_Y(geom) = ST_Y('
    ||quote_literal(apoint::text)||'::geometry)'
  LOOP
    RAISE EXCEPTION
     'SQL/MM Spatial exception - coincident node';
  END LOOP;

  --
  -- Get new node id
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.node_node_id_seq'')'
  LOOP
    nodeid = rec.nextval;
  END LOOP;

  --RAISE NOTICE 'Next node id = % ', nodeid;

  --
  -- Add the new node 
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.node(node_id, geom) 
    VALUES('||nodeid||','||quote_literal(apoint::text)||
    ')';

  --
  -- Compute new edge
  --
  newedge2 := ST_Split(oldedge.geom, apoint);
  newedge1 := ST_GeometryN(newedge2, 1);
  newedge2 := ST_GeometryN(newedge2, 2);

  --
  -- Get ids for the new edge
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.edge_data_edge_id_seq'')'
  LOOP
    newedgeid = rec.nextval;
  END LOOP;


  --
  -- Insert the new edge
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.edge '
    || '(edge_id, start_node, end_node,'
    || 'next_left_edge, next_right_edge,'
    || 'left_face, right_face, geom) '
    || 'VALUES('
    || newedgeid
    || ',' || nodeid
    || ',' || oldedge.end_node
    || ',' || COALESCE(                      -- next_left_edge
                NULLIF(
                  oldedge.next_left_edge,
                  -anedge
                ),
                -newedgeid
              )
    || ',' || -anedge                        -- next_right_edge
    || ',' || oldedge.left_face              -- left_face
    || ',' || oldedge.right_face             -- right_face
    || ',' || quote_literal(newedge2::text)  -- geom
    ||')';

  --
  -- Update the old edge
  --
  EXECUTE 'UPDATE ' || quote_ident(atopology) || '.edge_data '
    || ' SET geom = ' || quote_literal(newedge1::text)
    || ','
    || ' next_left_edge = ' || newedgeid
    || ', abs_next_left_edge = ' || newedgeid
    || ','
    || ' end_node = ' || nodeid
    || ' WHERE edge_id = ' || anedge;


  --
  -- Update all next edge references to match new layout
  --

  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET next_right_edge = '
    || -newedgeid 
    || ','
    || ' abs_next_right_edge = ' || newedgeid
    || ' WHERE edge_id != ' || newedgeid
    || ' AND next_right_edge = ' || -anedge;

  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.edge_data SET '
    || ' next_left_edge = ' || -newedgeid
    || ','
    || ' abs_next_left_edge = ' || newedgeid
    || ' WHERE edge_id != ' || newedgeid
    || ' AND next_left_edge = ' || -anedge;

  --
  -- Update references in the Relation table.
  -- We only take into considerations non-hierarchical
  -- TopoGeometry here, for obvious reasons.
  --
  FOR rec IN EXECUTE 'SELECT r.* FROM '
    || quote_ident(atopology)
    || '.relation r, topology.layer l '
    || ' WHERE '
    || ' l.topology_id = ' || topoid
    || ' AND l.level = 0 '
    || ' AND l.layer_id = r.layer_id '
    || ' AND abs(r.element_id) = ' || anedge
    || ' AND r.element_type = 2'
  LOOP
    --RAISE NOTICE 'TopoGeometry % in layer % contains the edge being split (%) - updating to add new edge %', rec.topogeo_id, rec.layer_id, anedge, newedgeid;

    -- Add new reference to edge1
    IF rec.element_id < 0 THEN
      tmp = -newedgeid;
    ELSE
      tmp = newedgeid;
    END IF;
    query = 'INSERT INTO ' || quote_ident(atopology)
      || '.relation '
      || ' VALUES( '
      || rec.topogeo_id
      || ','
      || rec.layer_id
      || ','
      || tmp
      || ','
      || rec.element_type
      || ')';

    --RAISE NOTICE '%', query;
    EXECUTE query;
  END LOOP;

  --RAISE NOTICE 'Edge % split in edges % and % by node %',
  --  anedge, anedge, newedgeid, nodeid;

  RETURN nodeid; 
END
]]></definition>
</function>

<function name="st_addisoedge"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anode, anothernode, alinestring - Adds an isolated edge defined by geometry alinestring to a topology connecting two existing isolated nodes anode and anothernode and returns the edge id of the new edge.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anode" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="anothernode" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="acurve" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  aface INTEGER;
  face GEOMETRY;
  snodegeom GEOMETRY;
  enodegeom GEOMETRY;
  count INTEGER;
  rec RECORD;
  edgeid INTEGER;
BEGIN

  --
  -- All arguments required
  -- 
  IF atopology IS NULL
     OR anode IS NULL
     OR anothernode IS NULL
     OR acurve IS NULL
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  -- NOT IN THE SPECS:
  -- A closed edge is never isolated (as it forms a face)
  IF anode = anothernode THEN
      RAISE EXCEPTION
       'Closed edges would not be isolated, try ST_AddEdgeNewFaces';
  END IF;

  --
  -- Acurve must be a LINESTRING
  --
  IF substring(geometrytype(acurve), 1, 4) != 'LINE'
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid curve';
  END IF;

  --
  -- Acurve must be simple
  --
  IF NOT ST_IsSimple(acurve)
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - curve not simple';
  END IF;

  --
  -- Check for:
  --    existence of nodes
  --    nodes faces match
  -- Extract:
  --    nodes face id
  --    nodes geoms
  --
  aface := NULL;
  count := 0;
  FOR rec IN EXECUTE 'SELECT geom, containing_face, node_id FROM '
    || quote_ident(atopology) || '.node
    WHERE node_id = ' || anode ||
    ' OR node_id = ' || anothernode
  LOOP 

    IF rec.containing_face IS NULL THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - not isolated node';
    END IF;

    IF aface IS NULL THEN
      aface := rec.containing_face;
    ELSE
      IF aface != rec.containing_face THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - nodes in different faces';
      END IF;
    END IF;

    -- Get nodes geom
    IF rec.node_id = anode THEN
      snodegeom = rec.geom;
    ELSE
      enodegeom = rec.geom;
    END IF;

    count = count+1;

  END LOOP;

  -- TODO: don't need count, can do with snodegeom/enodegeom instead..
  IF count < 2 THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  END IF;


  --
  -- l) Check that start point of acurve match start node
  -- geoms.
  -- 
  IF ST_X(snodegeom) != ST_X(ST_StartPoint(acurve)) OR
     ST_Y(snodegeom) != ST_Y(ST_StartPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - start node not geometry start point.';
  END IF;

  --
  -- m) Check that end point of acurve match end node
  -- geoms.
  -- 
  IF ST_X(enodegeom) != ST_X(ST_EndPoint(acurve)) OR
     ST_Y(enodegeom) != ST_Y(ST_EndPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - end node not geometry end point.';
  END IF;

  --
  -- n) Check if curve crosses (contains) any node
  -- I used _contains_ here to leave endpoints out
  -- 
  FOR rec IN EXECUTE 'SELECT node_id FROM '
    || quote_ident(atopology) || '.node '
    || ' WHERE geom && ' || quote_literal(acurve::text) 
    || ' AND ST_Contains(' || quote_literal(acurve::text)
    || ',geom)'
  LOOP
    RAISE EXCEPTION
      'SQL/MM Spatial exception - geometry crosses a node';
  END LOOP;

  --
  -- o) Check if curve intersects any other edge
  -- 
  FOR rec IN EXECUTE 'SELECT * FROM '
    || quote_ident(atopology) || '.edge_data
    WHERE ST_Intersects(geom, ' || quote_literal(acurve::text) || '::geometry)'
  LOOP
    RAISE EXCEPTION 'SQL/MM Spatial exception - geometry intersects an edge';
  END LOOP;

  --
  -- Get new edge id from sequence
  --
  FOR rec IN EXECUTE 'SELECT nextval(''' ||
    atopology || '.edge_data_edge_id_seq'')'
  LOOP
    edgeid = rec.nextval;
  END LOOP;

  -- TODO: this should likely be an exception instead !
  IF aface IS NULL THEN
    aface := 0;
  END IF;

  --
  -- Insert the new row
  --
  EXECUTE 'INSERT INTO ' || quote_ident(atopology)
    || '.edge VALUES(' || edgeid || ',' || anode
    || ',' || anothernode || ',' || (-edgeid)
    || ',' || edgeid || ','
    || aface || ',' || aface || ','
    || quote_literal(acurve::text) || ')';

  --
  -- Update Node containing_face values
  --
  -- the nodes anode and anothernode are no more isolated
  -- because now there is an edge connecting them
  -- 
  EXECUTE 'UPDATE ' || quote_ident(atopology)
    || '.node SET containing_face = NULL where (node_id ='
    || anode
    || ' OR node_id='
    || anothernode
    || ')';

  RETURN edgeid;

END
]]></definition>
</function>

<function name="_st_adjacentedges"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer" dimension="1"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anode" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="anedge" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  ret integer[];
BEGIN
  WITH edgestar AS (
    SELECT *, count(*) over () AS cnt
    FROM GetNodeEdges(atopology, anode)
  )
  SELECT ARRAY[ (
      SELECT p.edge AS prev FROM edgestar p
      WHERE p.sequence = CASE WHEN m.sequence-1 < 1 THEN cnt
                         ELSE m.sequence-1 END
    ), (
      SELECT p.edge AS prev FROM edgestar p WHERE p.sequence = ((m.sequence)%cnt)+1
    ) ]
  FROM edgestar m
  WHERE edge = anedge
  INTO ret;

  RETURN ret;
END
]]></definition>
</function>

<function name="st_changeedgegeom"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anedge, acurve - Changes the shape of an edge without affecting the topology structure.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anedge" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="acurve" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  rng_info RECORD; -- movement range info
  oldedge RECORD;
  range GEOMETRY; -- movement range
  tmp1 GEOMETRY;
  snode_info RECORD;
  enode_info RECORD;
  sql TEXT;
  iscw BOOLEAN;
BEGIN

  --
  -- All arguments required
  -- 
  IF atopology IS NULL
     OR anedge IS NULL
     OR acurve IS NULL
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Acurve must be a LINESTRING
  --
  IF substring(geometrytype(acurve), 1, 4) != 'LINE'
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - invalid curve';
  END IF;

  --
  -- Acurve must be a simple
  --
  IF NOT ST_IsSimple(acurve)
  THEN
    RAISE EXCEPTION
     'SQL/MM Spatial exception - curve not simple';
  END IF;

  --
  -- Get data about existing edge
  --
  BEGIN
    EXECUTE 'SELECT * FROM ' || quote_ident(atopology) || '.edge_data  '
      || ' WHERE edge_id = ' || anedge
    INTO STRICT oldedge;
  EXCEPTION
    -- NOT IN THE SPECS: check given edge existance
    WHEN NO_DATA_FOUND THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent edge %', anedge;
  END;

  --
  -- e) Check StartPoint consistency
  --
  IF NOT ST_Equals(ST_StartPoint(acurve), ST_StartPoint(oldedge.geom)) THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - start node not geometry start point.';
  END IF;

  IF oldedge.start_node = oldedge.end_node THEN -- {

    -- Not in the specs:
    -- if the edge is closed, check we didn't change winding !
    --       (should be part of isomorphism checking)
    range := ST_MakePolygon(oldedge.geom);
    iscw := ST_OrderingEquals(range, ST_ForceRHR(range));

    IF ST_NumPoints(ST_RemoveRepeatedPoints(acurve)) < 3 THEN
      RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
    END IF;
    range := ST_MakePolygon(acurve);

    IF iscw != ST_OrderingEquals(range, ST_ForceRHR(range)) THEN
      RAISE EXCEPTION 'Edge twist at node %',
        ST_AsText(ST_StartPoint(oldedge.geom));
    END IF;

  ELSE -- }{

    --
    -- f) Check EndPoint consistency
    --
    IF NOT ST_Equals(ST_EndPoint(acurve), ST_EndPoint(oldedge.geom)) THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - end node not geometry end point.';
    END IF;

  END IF; -- }

  --
  -- g) Check if curve crosses any node
  -- 
  FOR rec IN EXECUTE
    'SELECT node_id, ST_Relate(geom, '
    || quote_literal(acurve::text) || '::geometry, 2) as relate FROM '
    || quote_ident(atopology)
    || '.node WHERE geom && '
    || quote_literal(acurve::text)
    || '::geometry AND node_id NOT IN ('
    || oldedge.start_node || ',' || oldedge.end_node
    || ')'
  LOOP
    IF ST_RelateMatch(rec.relate, 'T********') THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - geometry crosses a node';
    END IF;
  END LOOP;

  --
  -- h) Check if this geometry has any interaction with any existing edge
  --
  sql := 'SELECT edge_id, ST_Relate(geom,' 
    || quote_literal(acurve::text)
    || '::geometry, 2) as im FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE edge_id != ' || anedge || ' AND geom && '
    || quote_literal(acurve::text) || '::geometry';
  FOR rec IN EXECUTE sql LOOP -- {

    --RAISE DEBUG 'IM=%',rec.im;

    IF ST_RelateMatch(rec.im, 'F********') THEN
      CONTINUE; -- no interior-interior intersection
    END IF;

    IF ST_RelateMatch(rec.im, '1FFF*FFF2') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - coincident edge %', rec.edge_id;
    END IF;

    -- NOT IN THE SPECS: geometry touches an edge
    IF ST_RelateMatch(rec.im, '1********') THEN
      RAISE EXCEPTION
        'Spatial exception - geometry intersects edge %', rec.edge_id;
    END IF;

    IF ST_RelateMatch(rec.im, 'T********') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - geometry crosses edge %', rec.edge_id;
    END IF;

  END LOOP; -- }

  --
  -- Not in the specs:
  -- Check topological isomorphism 
  --

  -- Check that the "motion range" doesn't include any node 
  --{

  sql := 'SELECT ST_Collect(geom) as nodes, '
    || 'null::geometry as r1, null::geometry as r2 FROM '
    || quote_ident(atopology)
    || '.node WHERE geom && '
    || quote_literal(ST_Collect(ST_Envelope(oldedge.geom),
                                ST_Envelope(acurve))::text)
    || '::geometry AND node_id NOT IN ( '
    || oldedge.start_node || ',' || oldedge.end_node || ')';
  EXECUTE sql INTO rng_info;

  -- There's no collision if there's no nodes in the combined
  -- bbox of old and new edges.
  --
  IF NOT ST_IsEmpty(rng_info.nodes) THEN -- {


    tmp1 := ST_MakeLine(ST_EndPoint(oldedge.geom), ST_StartPoint(oldedge.geom));

    rng_info.r1 := ST_MakeLine(oldedge.geom, tmp1);
    IF ST_NumPoints(rng_info.r1) < 4 THEN
      rng_info.r1 := ST_AddPoint(rng_info.r1, ST_StartPoint(oldedge.geom));
    END IF;
    rng_info.r1 := ST_CollectionExtract(
                       ST_MakeValid(ST_MakePolygon(rng_info.r1)), 3);

    rng_info.r2 := ST_MakeLine(acurve, tmp1);
    IF ST_NumPoints(rng_info.r2) < 4 THEN
      rng_info.r2 := ST_AddPoint(rng_info.r2, ST_StartPoint(oldedge.geom));
    END IF;
    rng_info.r2 := ST_CollectionExtract(
                       ST_MakeValid(ST_MakePolygon(rng_info.r2)), 3);

    FOR rec IN WITH
      nodes AS ( SELECT * FROM ST_Dump(rng_info.nodes) ),
      inr1 AS ( SELECT path[1] FROM nodes WHERE ST_Contains(rng_info.r1, geom) ),
      inr2 AS ( SELECT path[1] FROM nodes WHERE ST_Contains(rng_info.r2, geom) )
      ( SELECT * FROM inr1
          EXCEPT
        SELECT * FROM inr2
      ) UNION 
      ( SELECT * FROM inr2
          EXCEPT
        SELECT * FROM inr1
      )
    LOOP
      RAISE EXCEPTION 'Edge motion collision at %',
                     ST_AsText(ST_GeometryN(rng_info.nodes, rec.path));
    END LOOP;

  END IF; -- }

  --} motion range checking end

  -- 
  -- Check edge adjacency before
  --{

  SELECT topology._ST_AdjacentEdges(
      atopology, oldedge.start_node, anedge
    ) as pre, NULL::integer[] as post
  INTO STRICT snode_info;

  SELECT topology._ST_AdjacentEdges(
      atopology, oldedge.end_node, -anedge
    ) as pre, NULL::integer[] as post
  INTO STRICT enode_info;

  --}

  --
  -- Update edge geometry
  --
  EXECUTE 'UPDATE ' || quote_ident(atopology) || '.edge_data '
    || ' SET geom = ' || quote_literal(acurve::text) 
    || ' WHERE edge_id = ' || anedge;

  -- 
  -- Check edge adjacency after
  --{

  snode_info.post := topology._ST_AdjacentEdges(
      atopology, oldedge.start_node, anedge
    );

  enode_info.post := topology._ST_AdjacentEdges(
      atopology, oldedge.end_node, -anedge
    );

  IF snode_info.pre != snode_info.post THEN
    RAISE EXCEPTION 'Edge changed disposition around start node %',
      oldedge.start_node;
  END IF;

  IF enode_info.pre != enode_info.post THEN
    RAISE EXCEPTION 'Edge changed disposition around end node %',
      oldedge.end_node;
  END IF;

  --}

  -- Update faces MBR of left and right faces
  -- TODO: think about ways to optimize this part, like see if
  --       the old edge geometry partecipated in the definition
  --       of the current MBR (for shrinking) or the new edge MBR
  --       would be larger than the old face MBR...
  --
  IF oldedge.left_face != 0 THEN
    sql := 'UPDATE ' || quote_ident(atopology) || '.face '
      || ' SET mbr = ' || quote_literal(
        ST_Envelope(ST_GetFaceGeometry(atopology, oldedge.left_face))::text
        )
      || '::geometry WHERE face_id = ' || oldedge.left_face;
    EXECUTE sql;
  END IF;
  IF oldedge.right_face != 0 AND oldedge.right_face != oldedge.left_face THEN
    sql := 'UPDATE ' || quote_ident(atopology) || '.face '
      || ' SET mbr = ' || quote_literal(
        ST_Envelope(ST_GetFaceGeometry(atopology, oldedge.right_face))::text
        )
      || '::geometry WHERE face_id = ' || oldedge.right_face;
    EXECUTE sql;
  END IF;
  

  RETURN 'Edge ' || anedge || ' changed';

END
]]></definition>
</function>

<function name="_st_addfacesplit"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anedge" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="oface" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="mbr_only" in="true">
		<type name="boolean"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  fan RECORD;
  newface INTEGER;
  sql TEXT;
  isccw BOOLEAN;
  ishole BOOLEAN;

BEGIN

  IF oface = 0 AND mbr_only THEN
    RETURN NULL;
  END IF;

  SELECT null::int[] as newring_edges,
         null::geometry as shell
  INTO fan;

  SELECT array_agg(edge)
  FROM topology.getringedges(atopology, anedge)
  INTO STRICT fan.newring_edges;


  -- You can't get to the other side of an edge forming a ring 
  IF fan.newring_edges @> ARRAY[-anedge] THEN
    RETURN 0;
  END IF;


  sql := 'WITH ids as ( select row_number() over () as seq, edge from unnest('
    || quote_literal(fan.newring_edges::text)
    || '::int[] ) u(edge) ), edges AS ( select CASE WHEN i.edge < 0 THEN ST_Reverse(e.geom) ELSE e.geom END as g FROM ids i left join '
    || quote_ident(atopology) || '.edge_data e ON(e.edge_id = abs(i.edge)) ORDER BY seq) SELECT ST_MakePolygon(ST_MakeLine(g.g)) FROM edges g;';
  EXECUTE sql INTO fan.shell;


  isccw := NOT ST_OrderingEquals(fan.shell, ST_ForceRHR(fan.shell));


  IF oface = 0 THEN
    IF NOT isccw THEN
      RETURN NULL;
    END IF;
  END IF;

  IF mbr_only AND oface != 0 THEN
    -- Update old face mbr (nothing to do if we're opening an hole)
    IF isccw THEN -- {
      sql := 'UPDATE '
        || quote_ident(atopology) || '.face SET mbr = '
        || quote_literal(ST_Envelope(fan.shell)::text)
        || '::geometry WHERE face_id = ' || oface;
    	EXECUTE sql;
    END IF; -- }
    RETURN NULL;
  END IF;

  IF oface != 0 AND NOT isccw THEN -- {
    -- Face created an hole in an outer face
    sql := 'INSERT INTO '
      || quote_ident(atopology) || '.face(mbr) SELECT mbr FROM '
      || quote_ident(atopology)
      || '.face WHERE face_id = ' || oface
      || ' RETURNING face_id';
  ELSE
    sql := 'INSERT INTO '
      || quote_ident(atopology) || '.face(mbr) VALUES ('
      || quote_literal(ST_Envelope(fan.shell)::text)
      || '::geometry) RETURNING face_id';
  END IF; -- }

  -- Insert new face
  EXECUTE sql INTO STRICT newface;

  -- Update forward edges
  sql := 'UPDATE '
    || quote_ident(atopology) || '.edge_data SET left_face = ' || newface
    || ' WHERE left_face = ' || oface || ' AND edge_id = ANY ('
    || quote_literal(array( select +(x) from unnest(fan.newring_edges) u(x) )::text)
    || ')';
  EXECUTE sql;

  -- Update backward edges
  sql := 'UPDATE '
    || quote_ident(atopology) || '.edge_data SET right_face = ' || newface
    || ' WHERE right_face = ' || oface || ' AND edge_id = ANY ('
    || quote_literal(array( select -(x) from unnest(fan.newring_edges) u(x) )::text)
    || ')';
  EXECUTE sql;

  IF oface != 0 AND NOT isccw THEN -- {
    -- face shrinked, must update all non-contained edges and nodes
    ishole := true;
  ELSE
    ishole := false;
  END IF; -- }

  -- Update edges bounding the old face
  sql := 'UPDATE '
    || quote_ident(atopology)
    || '.edge_data SET left_face = CASE WHEN left_face = '
    || oface || ' THEN ' || newface
    || ' ELSE left_face END, right_face = CASE WHEN right_face = '
    || oface || ' THEN ' || newface
    || ' ELSE right_face END WHERE ( left_face = ' || oface
    || ' OR right_face = ' || oface
    || ') AND NOT edge_id = ANY ('
    || quote_literal( array(
        select abs(x) from unnest(fan.newring_edges) u(x)
       )::text )
    || ') AND ';
  IF ishole THEN sql := sql || 'NOT '; END IF;
  sql := sql || 'ST_Contains(' || quote_literal(fan.shell::text)
    -- We only need to check a single point, but must not be an endpoint
    || '::geometry, ST_LineInterpolatePoint(geom, 0.2))';
  EXECUTE sql;

  -- Update isolated nodes in new new face 
  sql := 'UPDATE '
    || quote_ident(atopology) || '.node SET containing_face = ' || newface
    || ' WHERE containing_face = ' || oface 
    || ' AND ';
  IF ishole THEN sql := sql || 'NOT '; END IF;
  sql := sql || 'ST_Contains(' || quote_literal(fan.shell::text) || '::geometry, geom)';
  EXECUTE sql;

  RETURN newface;

END
]]></definition>
</function>

<function name="st_addedgenewfaces"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anode, anothernode, acurve - Add a new edge and, if in doing so it splits a face, delete the original face and replace it with two new faces.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anode" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="anothernode" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="acurve" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  i INTEGER;
  topoid INTEGER;
  az FLOAT8;
  span RECORD; -- start point analysis data
  epan RECORD; --   end point analysis data
  fan RECORD; -- face analisys
  newedge RECORD; -- informations about new edge
  sql TEXT;
  newfaces INTEGER[];
  newface INTEGER;
BEGIN

  --
  -- All args required
  -- 
  IF atopology IS NULL
    OR anode IS NULL
    OR anothernode IS NULL
    OR acurve IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Acurve must be a LINESTRING
  --
  IF substring(geometrytype(acurve), 1, 4) != 'LINE'
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid curve';
  END IF;
  
  --
  -- Curve must be simple
  --
  IF NOT ST_IsSimple(acurve) THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - curve not simple';
  END IF;

  --
  -- Get topology id
  --
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = atopology;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  -- Initialize new edge info (will be filled up more later)
  SELECT anode as start_node, anothernode as end_node, acurve as geom,
    NULL::int as next_left_edge, NULL::int as next_right_edge,
    NULL::int as left_face, NULL::int as right_face, NULL::int as edge_id,
    NULL::int as prev_left_edge, NULL::int as prev_right_edge, -- convenience
    anode = anothernode as isclosed, -- convenience
    false as start_node_isolated, -- convenience
    false as end_node_isolated, -- convenience
    NULL::geometry as start_node_geom, -- convenience
    NULL::geometry as end_node_geom, -- convenience
    ST_RemoveRepeatedPoints(acurve) as cleangeom -- convenience
  INTO newedge;

  -- Compute azimuth of first edge end on start node
  SELECT null::int AS nextCW, null::int AS nextCCW,
         null::float8 AS minaz, null::float8 AS maxaz,
         false AS was_isolated,
         ST_Azimuth(ST_StartPoint(newedge.cleangeom),
                    ST_PointN(newedge.cleangeom, 2)) AS myaz
  INTO span;
  IF span.myaz IS NULL THEN
    RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
  END IF;

  -- Compute azimuth of last edge end on end node
  SELECT null::int AS nextCW, null::int AS nextCCW,
         null::float8 AS minaz, null::float8 AS maxaz,
         false AS was_isolated,
         ST_Azimuth(ST_EndPoint(newedge.cleangeom),
                    ST_PointN(newedge.cleangeom,
                              ST_NumPoints(newedge.cleangeom)-1)) AS myaz
  INTO epan;
  IF epan.myaz IS NULL THEN
    RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
  END IF;


  -- 
  -- Check endpoints existance, match with Curve geometry
  -- and get face information (if any)
  --
  i := 0;
  FOR rec IN EXECUTE 'SELECT node_id, containing_face, geom FROM '
    || quote_ident(atopology)
    || '.node WHERE node_id IN ( '
    || anode || ',' || anothernode
    || ')'
  LOOP
    IF rec.containing_face IS NOT NULL THEN
      IF newedge.left_face IS NULL THEN
        newedge.left_face := rec.containing_face;
        newedge.right_face := rec.containing_face;
      ELSE
        IF newedge.left_face != rec.containing_face THEN
          RAISE EXCEPTION
            'SQL/MM Spatial exception - geometry crosses an edge (endnodes in faces % and %)', newedge.left_face, rec.containing_face;
        END IF;
      END IF;
    END IF;

    IF rec.node_id = anode THEN
      newedge.start_node_geom = rec.geom;
    END IF;

    IF rec.node_id = anothernode THEN
      newedge.end_node_geom = rec.geom;
    END IF;

    i := i + 1;
  END LOOP;

  IF newedge.start_node_geom IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  ELSIF NOT Equals(newedge.start_node_geom, ST_StartPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - start node not geometry start point.';
  END IF;

  IF newedge.end_node_geom IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  ELSIF NOT Equals(newedge.end_node_geom, ST_EndPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - end node not geometry end point.';
  END IF;

  RAISE DEBUG 'All Checked !';

  --
  -- Check if this geometry crosses any node
  --
  FOR rec IN EXECUTE
    'SELECT node_id, ST_Relate(geom, '
    || quote_literal(acurve::text) || '::geometry, 2) as relate FROM '
    || quote_ident(atopology)
    || '.node WHERE geom && '
    || quote_literal(acurve::text)
    || '::geometry'
  LOOP
    IF ST_RelateMatch(rec.relate, 'T********') THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - geometry crosses a node';
    END IF;
  END LOOP;

  --
  -- Check if this geometry has any interaction with any existing edge
  --
  FOR rec IN EXECUTE 'SELECT edge_id, ST_Relate(geom,' 
    || quote_literal(acurve::text)
    || '::geometry, 2) as im FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE geom && '
    || quote_literal(acurve::text) || '::geometry'
  LOOP

    --RAISE DEBUG 'IM=%',rec.im;

    IF ST_RelateMatch(rec.im, 'F********') THEN
      CONTINUE; -- no interior intersection
    END IF;

    IF ST_RelateMatch(rec.im, '1FFF*FFF2') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - coincident edge %', rec.edge_id;
    END IF;

    -- NOT IN THE SPECS: geometry touches an edge
    IF ST_RelateMatch(rec.im, '1********') THEN
      RAISE EXCEPTION
        'Spatial exception - geometry intersects edge %', rec.edge_id;
    END IF;

    IF ST_RelateMatch(rec.im, 'T********') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - geometry crosses edge %', rec.edge_id;
    END IF;

  END LOOP;

  ---------------------------------------------------------------
  --
  -- All checks passed, time to prepare the new edge
  --
  ---------------------------------------------------------------

  EXECUTE 'SELECT nextval(' || quote_literal(
      quote_ident(atopology) || '.edge_data_edge_id_seq') || ')'
  INTO STRICT newedge.edge_id;


  -- Find links on start node -- {


  sql :=
    'SELECT edge_id, -1 AS end_node, start_node, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anode
    || ' UNION SELECT edge_id, end_node, -1, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE end_node = ' || anode;
  IF newedge.isclosed THEN
    sql := sql || ' UNION SELECT '
      || newedge.edge_id || ',' || newedge.end_node
      || ',-1,0,0,' -- pretend we start elsewhere
      || quote_literal(newedge.cleangeom::text);
  END IF;
  i := 0;
  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    i := i + 1;

    IF rec.start_node = anode THEN
      --
      -- Edge starts at our node, we compute
      -- azimuth from node to its second point
      --
      az := ST_Azimuth(ST_StartPoint(rec.geom), ST_PointN(rec.geom, 2));

    ELSE
      --
      -- Edge ends at our node, we compute
      -- azimuth from node to its second-last point
      --
      az := ST_Azimuth(ST_EndPoint(rec.geom),
                       ST_PointN(rec.geom, ST_NumPoints(rec.geom)-1));
      rec.edge_id := -rec.edge_id;

    END IF;

    IF az IS NULL THEN
      RAISE EXCEPTION 'Invalid edge % found (no two distinct nodes exist)',
        rec.edge_id;
    END IF;


    az = az - span.myaz;
    IF az < 0 THEN
      az := az + 2*PI();
    END IF;

    -- RAISE DEBUG ' normalized az %', az;

    IF span.maxaz IS NULL OR az > span.maxaz THEN
      span.maxaz := az;
      span.nextCCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.left_face := rec.left_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.left_face := rec.right_face;
        END IF;
      END IF;
    END IF;

    IF span.minaz IS NULL OR az < span.minaz THEN
      span.minaz := az;
      span.nextCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.right_face := rec.right_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.right_face := rec.left_face;
        END IF;
      END IF;
    END IF;

    --RAISE DEBUG 'Closest edges: CW:%(%) CCW:%(%)', span.nextCW, span.minaz, span.nextCCW, span.maxaz;

  END LOOP; -- incident edges }

  IF newedge.isclosed THEN
    IF i < 2 THEN span.was_isolated = true; END IF;
  ELSE
    IF i < 1 THEN span.was_isolated = true; END IF;
  END IF;

  IF span.nextCW IS NULL THEN
    -- This happens if the destination node is isolated
    newedge.next_right_edge := newedge.edge_id;
    newedge.prev_left_edge := -newedge.edge_id;
  ELSE
    newedge.next_right_edge := span.nextCW;
    newedge.prev_left_edge := -span.nextCCW;
  END IF;


  -- } start_node analysis


  -- Find links on end_node {
      

  sql :=
    'SELECT edge_id, -1 as end_node, start_node, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anothernode
    || 'UNION SELECT edge_id, end_node, -1, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE end_node = ' || anothernode;
  IF newedge.isclosed THEN
    sql := sql || ' UNION SELECT '
      || newedge.edge_id || ',' || -1 -- pretend we end elsewhere
      || ',' || newedge.start_node || ',0,0,'
      || quote_literal(newedge.cleangeom::text);
  END IF;
  i := 0;
  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    i := i + 1;

    IF rec.start_node = anothernode THEN
      --
      -- Edge starts at our node, we compute
      -- azimuth from node to its second point
      --
      az := ST_Azimuth(ST_StartPoint(rec.geom),
                       ST_PointN(rec.geom, 2));

    ELSE
      --
      -- Edge ends at our node, we compute
      -- azimuth from node to its second-last point
      --
      az := ST_Azimuth(ST_EndPoint(rec.geom),
        ST_PointN(rec.geom, ST_NumPoints(rec.geom)-1));
      rec.edge_id := -rec.edge_id;

    END IF;


    az := az - epan.myaz;
    IF az < 0 THEN
      az := az + 2*PI();
    END IF;

    -- RAISE DEBUG ' normalized az %', az;

    IF epan.maxaz IS NULL OR az > epan.maxaz THEN
      epan.maxaz := az;
      epan.nextCCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.right_face := rec.left_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.right_face := rec.right_face;
        END IF;
      END IF;
    END IF;

    IF epan.minaz IS NULL OR az < epan.minaz THEN
      epan.minaz := az;
      epan.nextCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.left_face := rec.right_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.left_face := rec.left_face;
        END IF;
      END IF;
    END IF;

    --RAISE DEBUG 'Closest edges: CW:%(%) CCW:%(%)', epan.nextCW, epan.minaz, epan.nextCCW, epan.maxaz;

  END LOOP; -- incident edges }

  IF newedge.isclosed THEN
    IF i < 2 THEN epan.was_isolated = true; END IF;
  ELSE
    IF i < 1 THEN epan.was_isolated = true; END IF;
  END IF;

  IF epan.nextCW IS NULL THEN
    -- This happens if the destination node is isolated
    newedge.next_left_edge := -newedge.edge_id;
    newedge.prev_right_edge := newedge.edge_id;
  ELSE
    newedge.next_left_edge := epan.nextCW;
    newedge.prev_right_edge := -epan.nextCCW;
  END IF;

  -- } end_node analysis


  ----------------------------------------------------------------------
  --
  -- If we don't have faces setup by now we must have encountered
  -- a malformed topology (no containing_face on isolated nodes, no
  -- left/right faces on adjacent edges or mismatching values)
  --
  ----------------------------------------------------------------------
  IF newedge.left_face != newedge.right_face THEN
    RAISE EXCEPTION 'Left(%)/right(%) faces mismatch: invalid topology ?', 
      newedge.left_face, newedge.right_face;
  END IF;
  IF newedge.left_face IS NULL THEN
    RAISE EXCEPTION 'Could not derive edge face from linked primitives: invalid topology ?';
  END IF;

  ----------------------------------------------------------------------
  --
  -- Insert the new edge, and update all linking
  --
  ----------------------------------------------------------------------

  -- Insert the new edge with what we have so far
  EXECUTE 'INSERT INTO ' || quote_ident(atopology) 
    || '.edge VALUES(' || newedge.edge_id
    || ',' || newedge.start_node
    || ',' || newedge.end_node
    || ',' || newedge.next_left_edge
    || ',' || newedge.next_right_edge
    || ',' || newedge.left_face
    || ',' || newedge.right_face
    || ',' || quote_literal(newedge.geom::geometry::text)
    || ')';

  -- Link prev_left_edge to us 
  -- (if it's not us already)
  IF abs(newedge.prev_left_edge) != newedge.edge_id THEN
    IF newedge.prev_left_edge > 0 THEN
      -- its next_left_edge is us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_left_edge = '
        || newedge.edge_id
        || ', abs_next_left_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || newedge.prev_left_edge;
    ELSE
      -- its next_right_edge is us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_right_edge = '
        || newedge.edge_id
        || ', abs_next_right_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || -newedge.prev_left_edge;
    END IF;
  END IF;

  -- Link prev_right_edge to us 
  -- (if it's not us already)
  IF abs(newedge.prev_right_edge) != newedge.edge_id THEN
    IF newedge.prev_right_edge > 0 THEN
      -- its next_left_edge is -us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_left_edge = '
        || -newedge.edge_id
        || ', abs_next_left_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || newedge.prev_right_edge;
    ELSE
      -- its next_right_edge is -us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_right_edge = '
        || -newedge.edge_id
        || ', abs_next_right_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || -newedge.prev_right_edge;
    END IF;
  END IF;

  -- NOT IN THE SPECS...
  -- set containing_face = null for start_node and end_node
  -- if they where isolated 
  IF span.was_isolated OR epan.was_isolated THEN
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.node SET containing_face = null WHERE node_id IN ('
        || anode || ',' || anothernode || ')';
  END IF;

  --------------------------------------------
  -- Check face splitting
  --------------------------------------------


  SELECT topology._ST_AddFaceSplit(atopology, -newedge.edge_id, newedge.left_face, false)
  INTO newface;

  IF newface = 0 THEN
    RETURN newedge.edge_id; 
  END IF;

  newfaces[1] := newface;

  SELECT topology._ST_AddFaceSplit(atopology, newedge.edge_id, newedge.left_face, false)
  INTO newface;

  newfaces[2] := newface;

  IF newedge.left_face != 0 THEN -- {

    -- NOT IN THE SPECS:
    -- update TopoGeometry compositions to substitute oldface with newfaces
    sql := 'UPDATE '
      || quote_ident(atopology)
      || '.relation r set element_id = ' || newfaces[1]
      || ' FROM topology.layer l '
      || ' WHERE l.topology_id = ' || topoid
      || ' AND l.level = 0 '
      || ' AND l.layer_id = r.layer_id '
      || ' AND r.element_id = ' || newedge.left_face
      || ' AND r.element_type = 3 RETURNING r.topogeo_id, r.layer_id';
    --RAISE DEBUG 'SQL: %', sql;
    FOR rec IN EXECUTE sql
    LOOP

      -- Add reference to the other face
      sql := 'INSERT INTO ' || quote_ident(atopology)
        || '.relation VALUES( ' || rec.topogeo_id
        || ',' || rec.layer_id || ',' || newfaces[2] || ', 3)';
      --RAISE DEBUG 'SQL: %', sql;
      EXECUTE sql;

    END LOOP;

    -- drop old face from faces table
    sql := 'DELETE FROM ' || quote_ident(atopology)
      || '.face WHERE face_id = ' || newedge.left_face;
    EXECUTE sql;

  END IF; -- }

  RETURN newedge.edge_id;
END
]]></definition>
</function>

<function name="st_addedgemodface"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, anode, anothernode, acurve - Add a new edge and, if in doing so it splits a face, modify the original face and add a new face.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="anode" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="anothernode" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="acurve" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  rrec RECORD;
  i INTEGER;
  topoid INTEGER;
  az FLOAT8;
  span RECORD; -- start point analysis data
  epan RECORD; --   end point analysis data
  fan RECORD; -- face analisys
  newedge RECORD; -- informations about new edge
  sql TEXT;
  newfaces INTEGER[];
  newface INTEGER;
BEGIN

  --
  -- All args required
  -- 
  IF atopology IS NULL
    OR anode IS NULL
    OR anothernode IS NULL
    OR acurve IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  --
  -- Acurve must be a LINESTRING
  --
  IF substring(geometrytype(acurve), 1, 4) != 'LINE'
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - invalid curve';
  END IF;
  
  --
  -- Curve must be simple
  --
  IF NOT ST_IsSimple(acurve) THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - curve not simple';
  END IF;

  --
  -- Get topology id
  --
  BEGIN
    SELECT id FROM topology.topology
      INTO STRICT topoid WHERE name = atopology;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  -- Initialize new edge info (will be filled up more later)
  SELECT anode as start_node, anothernode as end_node, acurve as geom,
    NULL::int as next_left_edge, NULL::int as next_right_edge,
    NULL::int as left_face, NULL::int as right_face, NULL::int as edge_id,
    NULL::int as prev_left_edge, NULL::int as prev_right_edge, -- convenience
    anode = anothernode as isclosed, -- convenience
    false as start_node_isolated, -- convenience
    false as end_node_isolated, -- convenience
    NULL::geometry as start_node_geom, -- convenience
    NULL::geometry as end_node_geom, -- convenience
    ST_RemoveRepeatedPoints(acurve) as cleangeom -- convenience
  INTO newedge;

  -- Compute azimut of first edge end on start node
  SELECT null::int AS nextCW, null::int AS nextCCW,
         null::float8 AS minaz, null::float8 AS maxaz,
         false AS was_isolated,
         ST_Azimuth(ST_StartPoint(newedge.cleangeom),
                    ST_PointN(newedge.cleangeom, 2)) AS myaz
  INTO span;
  IF span.myaz IS NULL THEN
    RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
  END IF;

  -- Compute azimuth of last edge end on end node
  SELECT null::int AS nextCW, null::int AS nextCCW,
         null::float8 AS minaz, null::float8 AS maxaz,
         false AS was_isolated,
         ST_Azimuth(ST_EndPoint(newedge.cleangeom),
                    ST_PointN(newedge.cleangeom,
                              ST_NumPoints(newedge.cleangeom)-1)) AS myaz
  INTO epan;
  IF epan.myaz IS NULL THEN
    RAISE EXCEPTION 'Invalid edge (no two distinct vertices exist)';
  END IF;


  -- 
  -- Check endpoints existance, match with Curve geometry
  -- and get face information (if any)
  --
  i := 0;
  FOR rec IN EXECUTE 'SELECT node_id, containing_face, geom FROM '
    || quote_ident(atopology)
    || '.node WHERE node_id IN ( '
    || anode || ',' || anothernode
    || ')'
  LOOP
    IF rec.containing_face IS NOT NULL THEN
      IF newedge.left_face IS NULL THEN
        newedge.left_face := rec.containing_face;
        newedge.right_face := rec.containing_face;
      ELSE
        IF newedge.left_face != rec.containing_face THEN
          RAISE EXCEPTION
            'SQL/MM Spatial exception - geometry crosses an edge (endnodes in faces % and %)', newedge.left_face, rec.containing_face;
        END IF;
      END IF;
    END IF;

    IF rec.node_id = anode THEN
      newedge.start_node_geom = rec.geom;
    END IF;

    IF rec.node_id = anothernode THEN
      newedge.end_node_geom = rec.geom;
    END IF;

    i := i + 1;
  END LOOP;

  IF newedge.start_node_geom IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  ELSIF NOT Equals(newedge.start_node_geom, ST_StartPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - start node not geometry start point.';
  END IF;

  IF newedge.end_node_geom IS NULL
  THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent node';
  ELSIF NOT Equals(newedge.end_node_geom, ST_EndPoint(acurve))
  THEN
    RAISE EXCEPTION
      'SQL/MM Spatial exception - end node not geometry end point.';
  END IF;

  --
  -- Check if this geometry crosses any node
  --
  FOR rec IN EXECUTE
    'SELECT node_id, ST_Relate(geom, '
    || quote_literal(acurve::text) || '::geometry, 2) as relate FROM '
    || quote_ident(atopology)
    || '.node WHERE geom && '
    || quote_literal(acurve::text)
    || '::geometry'
  LOOP
    IF ST_RelateMatch(rec.relate, 'T********') THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - geometry crosses a node';
    END IF;
  END LOOP;

  --
  -- Check if this geometry has any interaction with any existing edge
  --
  FOR rec IN EXECUTE 'SELECT edge_id, ST_Relate(geom,' 
    || quote_literal(acurve::text)
    || '::geometry, 2) as im FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE geom && '
    || quote_literal(acurve::text) || '::geometry'
  LOOP

    --RAISE DEBUG 'IM=%',rec.im;

    IF ST_RelateMatch(rec.im, 'F********') THEN
      CONTINUE; -- no interior intersection
    END IF;

    IF ST_RelateMatch(rec.im, '1FFF*FFF2') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - coincident edge %', rec.edge_id;
    END IF;

    -- NOT IN THE SPECS: geometry touches an edge
    IF ST_RelateMatch(rec.im, '1********') THEN
      RAISE EXCEPTION
        'Spatial exception - geometry intersects edge %', rec.edge_id;
    END IF;

    IF ST_RelateMatch(rec.im, 'T********') THEN
      RAISE EXCEPTION
        'SQL/MM Spatial exception - geometry crosses edge %', rec.edge_id;
    END IF;

  END LOOP;

  ---------------------------------------------------------------
  --
  -- All checks passed, time to prepare the new edge
  --
  ---------------------------------------------------------------

  EXECUTE 'SELECT nextval(' || quote_literal(
      quote_ident(atopology) || '.edge_data_edge_id_seq') || ')'
  INTO STRICT newedge.edge_id;


  -- Find links on start node -- {


  sql :=
    'SELECT edge_id, -1 AS end_node, start_node, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anode
    || ' UNION SELECT edge_id, end_node, -1, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE end_node = ' || anode;
  IF newedge.isclosed THEN
    sql := sql || ' UNION SELECT '
      || newedge.edge_id || ',' || newedge.end_node
      || ',-1,0,0,' -- pretend we start elsewhere
      || quote_literal(newedge.cleangeom::text);
  END IF;
  i := 0;
  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    i := i + 1;

    IF rec.start_node = anode THEN
      --
      -- Edge starts at our node, we compute
      -- azimuth from node to its second point
      --
      az := ST_Azimuth(ST_StartPoint(rec.geom), ST_PointN(rec.geom, 2));

    ELSE
      --
      -- Edge ends at our node, we compute
      -- azimuth from node to its second-last point
      --
      az := ST_Azimuth(ST_EndPoint(rec.geom),
                       ST_PointN(rec.geom, ST_NumPoints(rec.geom)-1));
      rec.edge_id := -rec.edge_id;

    END IF;

    IF az IS NULL THEN
      RAISE EXCEPTION 'Invalid edge % found (no two distinct nodes exist)',
        rec.edge_id;
    END IF;


    az = az - span.myaz;
    IF az < 0 THEN
      az := az + 2*PI();
    END IF;

    -- RAISE DEBUG ' normalized az %', az;

    IF span.maxaz IS NULL OR az > span.maxaz THEN
      span.maxaz := az;
      span.nextCCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.left_face := rec.left_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.left_face := rec.right_face;
        END IF;
      END IF;
    END IF;

    IF span.minaz IS NULL OR az < span.minaz THEN
      span.minaz := az;
      span.nextCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.right_face := rec.right_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.right_face := rec.left_face;
        END IF;
      END IF;
    END IF;

    --RAISE DEBUG 'Closest edges: CW:%(%) CCW:%(%)', span.nextCW, span.minaz, span.nextCCW, span.maxaz;

  END LOOP; -- incident edges }

  IF newedge.isclosed THEN
    IF i < 2 THEN span.was_isolated = true; END IF;
  ELSE
    IF i < 1 THEN span.was_isolated = true; END IF;
  END IF;

  IF span.nextCW IS NULL THEN
    -- This happens if the destination node is isolated
    newedge.next_right_edge := newedge.edge_id;
    newedge.prev_left_edge := -newedge.edge_id;
  ELSE
    newedge.next_right_edge := span.nextCW;
    newedge.prev_left_edge := -span.nextCCW;
  END IF;


  -- } start_node analysis


  -- Find links on end_node {
      

  sql :=
    'SELECT edge_id, -1 as end_node, start_node, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) as geom FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE start_node = ' || anothernode
    || 'UNION SELECT edge_id, end_node, -1, left_face, right_face, '
    || 'ST_RemoveRepeatedPoints(geom) FROM '
    || quote_ident(atopology)
    || '.edge_data WHERE end_node = ' || anothernode;
  IF newedge.isclosed THEN
    sql := sql || ' UNION SELECT '
      || newedge.edge_id || ',' || -1 -- pretend we end elsewhere
      || ',' || newedge.start_node || ',0,0,'
      || quote_literal(newedge.cleangeom::text);
  END IF;
  i := 0;
  FOR rec IN EXECUTE sql
  LOOP -- incident edges {

    i := i + 1;

    IF rec.start_node = anothernode THEN
      --
      -- Edge starts at our node, we compute
      -- azimuth from node to its second point
      --
      az := ST_Azimuth(ST_StartPoint(rec.geom),
                       ST_PointN(rec.geom, 2));

    ELSE
      --
      -- Edge ends at our node, we compute
      -- azimuth from node to its second-last point
      --
      az := ST_Azimuth(ST_EndPoint(rec.geom),
        ST_PointN(rec.geom, ST_NumPoints(rec.geom)-1));
      rec.edge_id := -rec.edge_id;

    END IF;


    az := az - epan.myaz;
    IF az < 0 THEN
      az := az + 2*PI();
    END IF;

    -- RAISE DEBUG ' normalized az %', az;

    IF epan.maxaz IS NULL OR az > epan.maxaz THEN
      epan.maxaz := az;
      epan.nextCCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.right_face := rec.left_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.right_face := rec.right_face;
        END IF;
      END IF;
    END IF;

    IF epan.minaz IS NULL OR az < epan.minaz THEN
      epan.minaz := az;
      epan.nextCW := rec.edge_id;
      IF abs(rec.edge_id) != newedge.edge_id THEN
        IF rec.edge_id < 0 THEN
          -- TODO: check for mismatch ?
          newedge.left_face := rec.right_face;
        ELSE
          -- TODO: check for mismatch ?
          newedge.left_face := rec.left_face;
        END IF;
      END IF;
    END IF;

    --RAISE DEBUG 'Closest edges: CW:%(%) CCW:%(%)', epan.nextCW, epan.minaz, epan.nextCCW, epan.maxaz;

  END LOOP; -- incident edges }

  IF newedge.isclosed THEN
    IF i < 2 THEN epan.was_isolated = true; END IF;
  ELSE
    IF i < 1 THEN epan.was_isolated = true; END IF;
  END IF;

  IF epan.nextCW IS NULL THEN
    -- This happens if the destination node is isolated
    newedge.next_left_edge := -newedge.edge_id;
    newedge.prev_right_edge := newedge.edge_id;
  ELSE
    newedge.next_left_edge := epan.nextCW;
    newedge.prev_right_edge := -epan.nextCCW;
  END IF;

  -- } end_node analysis


  ----------------------------------------------------------------------
  --
  -- If we don't have faces setup by now we must have encountered
  -- a malformed topology (no containing_face on isolated nodes, no
  -- left/right faces on adjacent edges or mismatching values)
  --
  ----------------------------------------------------------------------
  IF newedge.left_face != newedge.right_face THEN
    RAISE EXCEPTION 'Left(%)/right(%) faces mismatch: invalid topology ?', 
      newedge.left_face, newedge.right_face;
  END IF;
  IF newedge.left_face IS NULL THEN
    RAISE EXCEPTION 'Could not derive edge face from linked primitives: invalid topology ?';
  END IF;

  ----------------------------------------------------------------------
  --
  -- Insert the new edge, and update all linking
  --
  ----------------------------------------------------------------------

  -- Insert the new edge with what we have so far
  EXECUTE 'INSERT INTO ' || quote_ident(atopology) 
    || '.edge VALUES(' || newedge.edge_id
    || ',' || newedge.start_node
    || ',' || newedge.end_node
    || ',' || newedge.next_left_edge
    || ',' || newedge.next_right_edge
    || ',' || newedge.left_face
    || ',' || newedge.right_face
    || ',' || quote_literal(newedge.geom::geometry::text)
    || ')';

  -- Link prev_left_edge to us 
  -- (if it's not us already)
  IF abs(newedge.prev_left_edge) != newedge.edge_id THEN
    IF newedge.prev_left_edge > 0 THEN
      -- its next_left_edge is us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_left_edge = '
        || newedge.edge_id
        || ', abs_next_left_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || newedge.prev_left_edge;
    ELSE
      -- its next_right_edge is us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_right_edge = '
        || newedge.edge_id
        || ', abs_next_right_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || -newedge.prev_left_edge;
    END IF;
  END IF;

  -- Link prev_right_edge to us 
  -- (if it's not us already)
  IF abs(newedge.prev_right_edge) != newedge.edge_id THEN
    IF newedge.prev_right_edge > 0 THEN
      -- its next_left_edge is -us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_left_edge = '
        || -newedge.edge_id
        || ', abs_next_left_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || newedge.prev_right_edge;
    ELSE
      -- its next_right_edge is -us
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.edge_data SET next_right_edge = '
        || -newedge.edge_id
        || ', abs_next_right_edge = '
        || newedge.edge_id
        || ' WHERE edge_id = ' 
        || -newedge.prev_right_edge;
    END IF;
  END IF;

  -- NOT IN THE SPECS...
  -- set containing_face = null for start_node and end_node
  -- if they where isolated 
  IF span.was_isolated OR epan.was_isolated THEN
      EXECUTE 'UPDATE ' || quote_ident(atopology)
        || '.node SET containing_face = null WHERE node_id IN ('
        || anode || ',' || anothernode || ')';
  END IF;

  --------------------------------------------
  -- Check face splitting
  --------------------------------------------

  SELECT topology._ST_AddFaceSplit(atopology, newedge.edge_id, newedge.left_face, false)
  INTO newface;
  IF newface = 0 THEN
    RETURN newedge.edge_id; 
  END IF;

  IF newface IS NULL THEN -- must be forming a maximal ring in universal face
    SELECT topology._ST_AddFaceSplit(atopology, -newedge.edge_id, newedge.left_face, false)
    INTO newface;
  ELSE
    PERFORM topology._ST_AddFaceSplit(atopology, -newedge.edge_id, newedge.left_face, true);
  END IF;

  IF newface IS NULL THEN
    RETURN newedge.edge_id; 
  END IF;

  --------------------------------------------
  -- Update topogeometries, if needed
  --------------------------------------------

  IF newedge.left_face != 0 THEN -- {

    -- NOT IN THE SPECS:
    -- update TopoGeometry compositions to add newface
    sql := 'SELECT r.topogeo_id, r.layer_id FROM '
      || quote_ident(atopology)
      || '.relation r, topology.layer l '
      || ' WHERE l.topology_id = ' || topoid
      || ' AND l.level = 0 '
      || ' AND l.layer_id = r.layer_id '
      || ' AND r.element_id = ' || newedge.left_face
      || ' AND r.element_type = 3 ';
    --RAISE DEBUG 'SQL: %', sql;
    FOR rec IN EXECUTE sql
    LOOP

      -- Add reference to the other face
      sql := 'INSERT INTO ' || quote_ident(atopology)
        || '.relation VALUES( ' || rec.topogeo_id
        || ',' || rec.layer_id || ',' || newface || ', 3)';
      --RAISE DEBUG 'SQL: %', sql;
      EXECUTE sql;

    END LOOP;

  END IF; -- }

  RETURN newedge.edge_id;
END
]]></definition>
</function>

<function name="st_inittopogeo"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: topology_schema_name - Creates a new topology schema and registers this new schema in the topology.topology table and details summary of process.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  rec RECORD;
  topology_id numeric;
BEGIN
  IF atopology IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  FOR rec IN SELECT * FROM pg_namespace WHERE text(nspname) = atopology
  LOOP
    RAISE EXCEPTION 'SQL/MM Spatial exception - schema already exists';
  END LOOP;

  FOR rec IN EXECUTE 'SELECT topology.CreateTopology('
    ||quote_literal(atopology)|| ') as id'
  LOOP
    topology_id := rec.id;
  END LOOP;

  RETURN 'Topology-Geometry ' || quote_literal(atopology)
    || ' (id:' || topology_id || ') created.';
END
]]></definition>
</function>

<function name="st_createtopogeo"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<comment><![CDATA[args: atopology, acollection - Adds a collection of geometries to a given empty topology and returns a message detailing success.]]></comment>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="atopology" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="acollection" in="true">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  typ char(4);
  rec RECORD;
  ret int;
  nodededges GEOMETRY;
  points GEOMETRY;
  snode_id int;
  enode_id int;
  tolerance FLOAT8;
  topoinfo RECORD;
BEGIN

  IF atopology IS NULL OR acollection IS NULL THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - null argument';
  END IF;

  -- Get topology information
  BEGIN
    SELECT * FROM topology.topology
      INTO STRICT topoinfo WHERE name = atopology;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
  END;

  -- Check SRID compatibility
  IF ST_SRID(acollection) != topoinfo.SRID THEN
    RAISE EXCEPTION 'Geometry SRID (%) does not match topology SRID (%)',
      ST_SRID(acollection), topoinfo.SRID;
  END IF;

  -- Verify pre-conditions (valid, empty topology schema exists)
  BEGIN -- {

    -- Verify the topology views in the topology schema to be empty
    FOR rec in EXECUTE
      'SELECT count(*) FROM '
      || quote_ident(atopology) || '.edge_data '
      || ' UNION ' ||
      'SELECT count(*) FROM '
      || quote_ident(atopology) || '.node '
    LOOP
      IF rec.count > 0 THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-empty view';
      END IF;
    END LOOP;

    -- face check is separated as it will contain a single (world)
    -- face record
    FOR rec in EXECUTE
      'SELECT count(*) FROM '
      || quote_ident(atopology) || '.face '
    LOOP
      IF rec.count != 1 THEN
    RAISE EXCEPTION 'SQL/MM Spatial exception - non-empty face view';
      END IF;
    END LOOP;

  EXCEPTION
    WHEN INVALID_SCHEMA_NAME THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - invalid topology name';
    WHEN UNDEFINED_TABLE THEN
      RAISE EXCEPTION 'SQL/MM Spatial exception - non-existent view';

  END; -- }


  --
  -- Node input linework with itself
  --
  WITH components AS ( SELECT geom FROM ST_Dump(acollection) )
  SELECT ST_UnaryUnion(ST_Collect(geom)) FROM (
    SELECT geom FROM components
      WHERE ST_Dimension(geom) = 1
    UNION ALL
    SELECT ST_Boundary(geom) FROM components
      WHERE ST_Dimension(geom) = 2
  ) as linework INTO STRICT nodededges;


  --
  -- Linemerge the resulting edges, to reduce the working set
  -- NOTE: this is more of a workaround for GEOS splitting overlapping
  --       lines to each of the segments.
  --
  SELECT ST_LineMerge(nodededges) INTO STRICT nodededges;



  --
  -- Collect input points and input lines endpoints
  --
  WITH components AS ( SELECT geom FROM ST_Dump(acollection) )
  SELECT ST_Union(geom) FROM (
    SELECT geom FROM components
      WHERE ST_Dimension(geom) = 0
    UNION ALL
    SELECT ST_Boundary(geom) FROM components
      WHERE ST_Dimension(geom) = 1
  ) as nodes INTO STRICT points;


  --
  -- Further split edges by points
  -- TODO: optimize this adding ST_Split support for multiline/multipoint
  --
  FOR rec IN SELECT geom FROM ST_Dump(points)
  LOOP
    -- Use the node to split edges
    SELECT ST_Collect(geom) 
    FROM ST_Dump(ST_Split(nodededges, rec.geom))
    INTO STRICT nodededges;
  END LOOP;
  SELECT ST_UnaryUnion(nodededges) INTO STRICT nodededges;


  --
  -- Collect all nodes (from points and noded linework endpoints)
  --

  WITH edges AS ( SELECT geom FROM ST_Dump(nodededges) )
  SELECT ST_Union( -- TODO: ST_UnaryUnion ?
          COALESCE(ST_UnaryUnion(ST_Collect(geom)), 
            ST_SetSRID('POINT EMPTY'::geometry, topoinfo.SRID)),
          COALESCE(points,
            ST_SetSRID('POINT EMPTY'::geometry, topoinfo.SRID))
         )
  FROM (
    SELECT ST_StartPoint(geom) as geom FROM edges
      UNION ALL
    SELECT ST_EndPoint(geom) FROM edges
  ) as endpoints INTO points;


  --
  -- Add all nodes as isolated so that 
  -- later calls to AddEdgeModFace will tweak their being
  -- isolated or not...
  --
  FOR rec IN SELECT geom FROM ST_Dump(points)
  LOOP
    PERFORM topology.ST_AddIsoNode(atopology, 0, rec.geom);
  END LOOP;
  

  FOR rec IN SELECT geom FROM ST_Dump(nodededges)
  LOOP
    SELECT topology.GetNodeByPoint(atopology, st_startpoint(rec.geom), 0)
      INTO STRICT snode_id;
    SELECT topology.GetNodeByPoint(atopology, st_endpoint(rec.geom), 0)
      INTO STRICT enode_id;
    PERFORM topology.ST_AddEdgeModFace(atopology, snode_id, enode_id, rec.geom);
  END LOOP;

  RETURN 'Topology ' || atopology || ' populated';

END
]]></definition>
</function>

<function name="addtosearchpath"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="a_schema_name" in="true">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	var_result text;
	var_cur_search_path text;
BEGIN
	SELECT reset_val INTO var_cur_search_path FROM pg_settings WHERE name = 'search_path';
	IF var_cur_search_path LIKE '%' || quote_ident(a_schema_name) || '%' THEN
		var_result := a_schema_name || ' already in database search_path';
	ELSE
		EXECUTE 'ALTER DATABASE ' || quote_ident(current_database()) || ' SET search_path = ' || var_cur_search_path || ', ' || quote_ident(a_schema_name); 
		var_result := a_schema_name || ' has been added to end of database search_path ';
	END IF;
  
  RETURN var_result;
END
]]></definition>
</function>

<function name="postgis_topology_scripts_installed"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<definition><![CDATA[ SELECT '2.1.0'::text || ' r' || 11822::text AS version ]]></definition>
</function>

<function name="_st_remedgecheck"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="topology"/>
	<role name="postgres"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="tname" in="true">
		<type name="character varying"/>
	</parameter>
	<parameter name="tid" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="eid" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="lf" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="rf" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
  sql text;
  fidary int[];
  rec RECORD;
BEGIN
  -- Check that no TopoGeometry references the edge being removed
  sql := 'SELECT r.topogeo_id, r.layer_id'
      || ', l.schema_name, l.table_name, l.feature_column '
      || 'FROM topology.layer l INNER JOIN '
      || quote_ident(tname)
      || '.relation r ON (l.layer_id = r.layer_id) '
      || 'WHERE l.level = 0 AND l.feature_type = 2 '
      || ' AND l.topology_id = ' || tid
      || ' AND abs(r.element_id) = ' || eid ;
  FOR rec IN EXECUTE sql LOOP
    RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented dropping edge %',
            rec.topogeo_id, rec.layer_id,
            rec.schema_name, rec.table_name, rec.feature_column,
            eid;
  END LOOP;

  IF lf != rf THEN -- {

    RAISE NOTICE 'Deletion of edge % joins faces % and %',
                    eid, lf, rf;

    -- check if any topo_geom is defined only by one of the
    -- joined faces. In such case there would be no way to adapt
    -- the definition in case of healing, so we'd have to bail out
    -- 
    fidary = ARRAY[lf, rf];
    sql := 'SELECT t.* from ('
      || 'SELECT r.topogeo_id, r.layer_id'
      || ', l.schema_name, l.table_name, l.feature_column'
      || ', array_agg(r.element_id) as elems '
      || 'FROM topology.layer l INNER JOIN '
      || quote_ident(tname)
      || '.relation r ON (l.layer_id = r.layer_id) '
      || 'WHERE l.level = 0 AND l.feature_type = 3 '
      || ' AND l.topology_id = ' || tid
      || ' AND r.element_id = ANY (' || quote_literal(fidary)
      || ') group by r.topogeo_id, r.layer_id, l.schema_name, l.table_name, '
      || ' l.feature_column ) t';

    -- No surface can be defined by universal face 
    IF lf != 0 AND rf != 0 THEN -- {
      sql := sql || ' WHERE NOT t.elems @> ' || quote_literal(fidary);
    END IF; -- }


    FOR rec IN EXECUTE sql LOOP
      RAISE EXCEPTION 'TopoGeom % in layer % (%.%.%) cannot be represented healing faces % and %',
            rec.topogeo_id, rec.layer_id,
            rec.schema_name, rec.table_name, rec.feature_column,
            rf, lf;
    END LOOP;

  END IF; -- } two faces healed...
END
]]></definition>
</function>

<sequence name="face_face_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<table name="face">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<position x="357.182" y="975"/>
	<column name="face_id" not-null="true" default-value="nextval('face_face_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="mbr">
		<type name="geometry" spatial-type="POLYGON" variation="0" srid="932011"/>
	</column>
	<constraint name="face_primary_key" type="pk-constr" factor="100" table="demo_zone_test.face">
		<columns names="face_id" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="node_node_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<table name="node">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<position x="590.432" y="575"/>
	<column name="node_id" not-null="true" default-value="nextval('node_node_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="containing_face">
		<type name="integer"/>
	</column>
	<column name="geom">
		<type name="geometry" spatial-type="POINT" variation="0" srid="932011"/>
	</column>
	<constraint name="node_primary_key" type="pk-constr" factor="100" table="demo_zone_test.node">
		<columns names="node_id" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="edge_data_edge_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<table name="edge_data">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<position x="999.432" y="575"/>
	<column name="edge_id" not-null="true" default-value="nextval('edge_data_edge_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="start_node" not-null="true">
		<type name="integer"/>
	</column>
	<column name="end_node" not-null="true">
		<type name="integer"/>
	</column>
	<column name="next_left_edge" not-null="true">
		<type name="integer"/>
	</column>
	<column name="abs_next_left_edge" not-null="true">
		<type name="integer"/>
	</column>
	<column name="next_right_edge" not-null="true">
		<type name="integer"/>
	</column>
	<column name="abs_next_right_edge" not-null="true">
		<type name="integer"/>
	</column>
	<column name="left_face" not-null="true">
		<type name="integer"/>
	</column>
	<column name="right_face" not-null="true">
		<type name="integer"/>
	</column>
	<column name="geom">
		<type name="geometry" spatial-type="LINESTRING" variation="0" srid="932011"/>
	</column>
	<constraint name="edge_data_pkey" type="pk-constr" factor="100" table="demo_zone_test.edge_data">
		<columns names="edge_id" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="layer_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<table name="relation">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<position x="1474.43" y="575"/>
	<column name="topogeo_id" not-null="true">
		<type name="integer"/>
	</column>
	<column name="layer_id" not-null="true">
		<type name="integer"/>
	</column>
	<column name="element_id" not-null="true">
		<type name="integer"/>
	</column>
	<column name="element_type" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="relation_layer_id_topogeo_id_element_id_element_type_key" type="uq-constr" factor="100" table="demo_zone_test.relation">
		<columns names="layer_id,topogeo_id,element_id,element_type" ref-type="src-columns"/>
	</constraint>
	<trigger name="relation_integrity_checks" firing-type="BEFORE" per-line="true" constraint="false"
		 ins-event="true" del-event="false" upd-event="true" trunc-event="false" arguments="45,demo_zone_test"
	 table="demo_zone_test.relation">
		<function signature="topology.relationtrigger()"/>
	</trigger>
</table>

<function name="geometry_gist_distance_2d"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="integer"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="gserialized_gist_distance_2d"/>
</function>

<function name="geometry_gist_consistent_2d"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="geometry"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="integer"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="gserialized_gist_consistent_2d"/>
</function>

<function name="geometry_gist_union_2d"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="internal"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bytea"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="internal"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="gserialized_gist_union_2d"/>
</function>

<function name="geometry_gist_compress_2d"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="internal"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="gserialized_gist_compress_2d"/>
</function>

<function name="geometry_gist_decompress_2d"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="internal"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="gserialized_gist_decompress_2d"/>
</function>

<function name="geometry_gist_penalty_2d"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="internal"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="internal"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="gserialized_gist_penalty_2d"/>
</function>

<function name="geometry_gist_picksplit_2d"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="c" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="internal"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="internal"/>
	</parameter>
	<definition library="$libdir/postgis-2.1" symbol="gserialized_gist_picksplit_2d"/>
</function>

<language name="internal" sql-disabled="true" trusted="false">
	<role name="postgres"/>
</language>

<function name="btint2cmp" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less-equal-greater]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[btint2cmp]]></definition>
</function>

<function name="btint24cmp" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less-equal-greater]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[btint24cmp]]></definition>
</function>

<function name="btint28cmp" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less-equal-greater]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[btint28cmp]]></definition>
</function>

<function name="btint4cmp" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less-equal-greater]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[btint4cmp]]></definition>
</function>

<function name="btint48cmp" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less-equal-greater]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[btint48cmp]]></definition>
</function>

<function name="btint42cmp" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less-equal-greater]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[btint42cmp]]></definition>
</function>

<function name="btint84cmp" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less-equal-greater]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[btint84cmp]]></definition>
</function>

<function name="btint82cmp" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less-equal-greater]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[btint82cmp]]></definition>
</function>

<function name="int2lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int2lt]]></definition>
</function>

<function name="scalarltsel" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[restriction selectivity of < and related operators on scalar datatypes]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="oid"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param4" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[scalarltsel]]></definition>
</function>

<function name="scalarltjoinsel" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[join selectivity of < and related operators on scalar datatypes]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="oid"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param4" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param5" in="true">
		<type name="internal"/>
	</parameter>
	<definition><![CDATA[scalarltjoinsel]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int2lt(IN smallint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int2le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int2le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int2le(IN smallint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int2eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int2eq]]></definition>
</function>

<function name="eqsel" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[restriction selectivity of = and related operators]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="oid"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param4" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[eqsel]]></definition>
</function>

<function name="eqjoinsel" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[join selectivity of = and related operators]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="oid"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param4" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param5" in="true">
		<type name="internal"/>
	</parameter>
	<definition><![CDATA[eqjoinsel]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int2eq(IN smallint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int2ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int2ge]]></definition>
</function>

<function name="scalargtsel" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[restriction selectivity of > and related operators on scalar datatypes]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="oid"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param4" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[scalargtsel]]></definition>
</function>

<function name="scalargtjoinsel" sql-disabled="true"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="STABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[join selectivity of > and related operators on scalar datatypes]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="double precision"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="oid"/>
	</parameter>
	<parameter name="_param3" in="true">
		<type name="internal"/>
	</parameter>
	<parameter name="_param4" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param5" in="true">
		<type name="internal"/>
	</parameter>
	<definition><![CDATA[scalargtjoinsel]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int2ge(IN smallint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int2gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int2gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int2gt(IN smallint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int24lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int24lt]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int24lt(IN smallint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int24le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int24le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int24le(IN smallint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int24eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int24eq]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int24eq(IN smallint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int24ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int24ge]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int24ge(IN smallint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int24gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int24gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int24gt(IN smallint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int28lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int28lt]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int28lt(IN smallint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int28le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int28le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int28le(IN smallint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int28eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int28eq]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int28eq(IN smallint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int28ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int28ge]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int28ge(IN smallint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int28gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="smallint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int28gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="smallint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int28gt(IN smallint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int4lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int4lt]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int4lt(IN integer,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int4le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int4le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int4le(IN integer,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int4eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int4eq]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int4eq(IN integer,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int4ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int4ge]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int4ge(IN integer,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int4gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int4gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int4gt(IN integer,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int42lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int42lt]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int42lt(IN integer,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int42le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int42le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int42le(IN integer,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int42eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int42eq]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<operator ref-type="commutator-op" signature="pg_catalog.=(smallint,integer)"/>
	<function ref-type="operfunc" signature="pg_catalog.int42eq(IN integer,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int42ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int42ge]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int42ge(IN integer,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int42gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int42gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int42gt(IN integer,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int48lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int48lt]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int48lt(IN integer,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int48le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int48le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int48le(IN integer,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int48eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int48eq]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int48eq(IN integer,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int48ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int48ge]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int48ge(IN integer,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int48gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="integer"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int48gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="integer" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int48gt(IN integer,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int8lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int8lt]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int8lt(IN bigint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int8le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int8le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int8le(IN bigint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int8eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int8eq]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int8eq(IN bigint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int8ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int8ge]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int8ge(IN bigint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int8gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="bigint"/>
	</parameter>
	<definition><![CDATA[int8gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="bigint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int8gt(IN bigint,IN bigint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int82lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int82lt]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int82lt(IN bigint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int82le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int82le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int82le(IN bigint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int82eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int82eq]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<operator ref-type="commutator-op" signature="pg_catalog.=(smallint,bigint)"/>
	<function ref-type="operfunc" signature="pg_catalog.int82eq(IN bigint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int82ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int82ge]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int82ge(IN bigint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int82gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="smallint"/>
	</parameter>
	<definition><![CDATA[int82gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="smallint" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int82gt(IN bigint,IN smallint)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int84lt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of < operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int84lt]]></definition>
</function>

<operator name="&lt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int84lt(IN bigint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int84le" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of <= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int84le]]></definition>
</function>

<operator name="&lt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[less than or equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int84le(IN bigint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalarltjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalarltsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int84eq" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of = operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int84eq]]></definition>
</function>

<operator name="=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<operator ref-type="commutator-op" signature="pg_catalog.=(integer,bigint)"/>
	<function ref-type="operfunc" signature="pg_catalog.int84eq(IN bigint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.eqjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.eqsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int84ge" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of >= operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int84ge]]></definition>
</function>

<operator name="&gt;=" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than or equal]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int84ge(IN bigint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<function name="int84gt" sql-disabled="true"
		window-func="false"
		leakproof="true"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="1"
		row-amount="0">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[implementation of > operator]]></comment>
	<language name="internal" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="_param1" in="true">
		<type name="bigint"/>
	</parameter>
	<parameter name="_param2" in="true">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[int84gt]]></definition>
</function>

<operator name="&gt;" sql-disabled="true">
	<schema name="pg_catalog"/>
	<role name="postgres"/>
	<comment><![CDATA[greater than]]></comment>
	<type name="bigint" ref-type="left-type"/>
	<type name="integer" ref-type="right-type"/>
	<function ref-type="operfunc" signature="pg_catalog.int84gt(IN bigint,IN integer)"/>
	<function ref-type="join" signature="pg_catalog.scalargtjoinsel(IN internal,IN oid,IN internal,IN smallint,IN internal)"/>
	<function ref-type="restriction" signature="pg_catalog.scalargtsel(IN internal,IN oid,IN internal,IN integer)"/>
</operator>

<sequence name="route_demo_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<table name="route_demo">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<position x="1798.2" y="575"/>
	<column name="gid" not-null="true" default-value="nextval('route_demo_gid_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="id">
		<type name="text"/>
	</column>
	<column name="tg">
		<type name="smallint"/>
	</column>
	<constraint name="route_demo_pkey" type="pk-constr" factor="100" table="demo_zone_test.route_demo">
		<columns names="gid" ref-type="src-columns"/>
	</constraint>
	<constraint name="check_topogeom_tg" type="ck-constr" table="demo_zone_test.route_demo">
			<expression><![CDATA[((((tg).topology_id = 45) AND ((tg).layer_id = 1)) AND ((tg).type = 2))]]></expression>
	</constraint>
	<constraint name="route_demo_unique_tg" type="uq-constr" factor="100" table="demo_zone_test.route_demo">
		<columns names="tg" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="topogeo_s_1"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<sequence name="intersection_point_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<sequence name="topogeo_s_2"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<usertype name="intersection_data" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="geom">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff_l">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="largeur">
		<type name="double precision"/>
	</typeattrib>
</usertype>

<usertype name="seg_pair" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" length="24" dimension="1"/>
	</typeattrib>
	<typeattrib name="id1">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="id2">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="geom_buff1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff_l1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff_l2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_seg1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_seg2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="segments_per_intersection">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="largeur1">
		<type name="double precision"/>
	</typeattrib>
	<typeattrib name="largeur2">
		<type name="double precision"/>
	</typeattrib>
</usertype>

<usertype name="circle_centers" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" length="24" dimension="1"/>
	</typeattrib>
	<typeattrib name="id1">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="id2">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="geom_buff1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff_l1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff_l2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_seg1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_seg2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="segments_per_intersection">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="largeur1">
		<type name="double precision"/>
	</typeattrib>
	<typeattrib name="largeur2">
		<type name="double precision"/>
	</typeattrib>
	<typeattrib name="ccircle">
		<type name="geometry"/>
	</typeattrib>
</usertype>

<usertype name="projected_points" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" length="24" dimension="1"/>
	</typeattrib>
	<typeattrib name="ccircle">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_buff2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="pt1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="pt2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="pt_b1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="pt_b2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_seg1">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_seg2">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry"/>
	</typeattrib>
</usertype>

<usertype name="border_points_on_line" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="id_qgis">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="ccircle">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="geom_pts">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="pt_b">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="segs_geom">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry"/>
	</typeattrib>
</usertype>

<usertype name="split_segment" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="qgis_id">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="geom_pts">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="segs_geom">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="cut_seg">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="in_intersection">
		<type name="bigint"/>
	</typeattrib>
</usertype>

<usertype name="road_section_m" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="qgis_id">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry" dimension="1"/>
	</typeattrib>
	<typeattrib name="intersection_limit">
		<type name="geometry" dimension="1"/>
	</typeattrib>
	<typeattrib name="in_intersection">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="road_section">
		<type name="geometry"/>
	</typeattrib>
</usertype>

<usertype name="simple_intersection_surface" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="gid">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="qgis_id">
		<type name="bigint" dimension="1"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" dimension="1"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="in_intersection">
		<type name="integer" dimension="1"/>
	</typeattrib>
	<typeattrib name="largeur">
		<type name="double precision" dimension="1"/>
	</typeattrib>
	<typeattrib name="geom_buff">
		<type name="geometry"/>
	</typeattrib>
</usertype>

<usertype name="arcs_for_intersection" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="arc">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="ccircle">
		<type name="geometry" dimension="1"/>
	</typeattrib>
</usertype>

<usertype name="intersection_surface" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="qgis_id">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry"/>
	</typeattrib>
	<typeattrib name="poly">
		<type name="geometry"/>
	</typeattrib>
</usertype>

<usertype name="road_section_surface" configuration="composite">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
	<typeattrib name="tableoid">
		<type name="oid"/>
	</typeattrib>
	<typeattrib name="cmax">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmax">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="cmin">
		<type name="cid"/>
	</typeattrib>
	<typeattrib name="xmin">
		<type name="xid"/>
	</typeattrib>
	<typeattrib name="ctid">
		<type name="tid"/>
	</typeattrib>
	<typeattrib name="qgis_id">
		<type name="bigint"/>
	</typeattrib>
	<typeattrib name="id">
		<type name="character varying" length="24"/>
	</typeattrib>
	<typeattrib name="intersection_point">
		<type name="geometry" dimension="1"/>
	</typeattrib>
	<typeattrib name="intersection_limit">
		<type name="geometry" dimension="1"/>
	</typeattrib>
	<typeattrib name="largeur">
		<type name="double precision"/>
	</typeattrib>
	<typeattrib name="geom_buff">
		<type name="geometry"/>
	</typeattrib>
</usertype>

<sequence name="intersection_ccenters_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<sequence name="topogeo_s_3"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<sequence name="intersection_limit_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<sequence name="topogeo_s_4"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<sequence name="route_section_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

<sequence name="topogeo_s_5"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="demo_zone_test"/>
	<role name="postgres"/>
</sequence>

</dbmodel>
